<!doctype html><html><body><h3>Documentation for sbitset.h</h3><br><i>sb_t *</i><b>sb_alloca</b>(<i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate bitset (stack)</li><li><b>const size_t initial_num_elems_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>sb_t *</i>): bitset</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sb_t *</i><b>sb_alloc</b>(<i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate bitset (heap)</li><li><b>const size_t initial_num_elems_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>sb_t *</i>): bitset</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sb_t *</i><b>sb_free</b>(<i>sb_t **b</i>, <i>...</i>)<br><br><ul><li>Free one or more bitsets (heap)</li><li><b>sb_t **b</b>: bitset</li><li><b>...</b>:  more bitsets (optional)</li><li><b>Return</b> (<i>sb_t *</i>): bitset</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sb_t *</i><b>sb_shrink</b>(<i>sb_t **c</i>)<br><br><ul><li>Free unused space</li><li><b>sb_t **c</b>: bitset</li><li><b>Return</b> (<i>sb_t *</i>): same bitset (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sb_t *</i><b>sb_dup</b>(<i>const sb_t *src</i>)<br><br><ul><li>Duplicate bitset</li><li><b>const sb_t *src</b>: bitset</li><li><b>Return</b> (<i>sb_t *</i>): output bitset</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sb_t *</i><b>sb_reset</b>(<i>const sb_t *src</i>)<br><br><ul><li>Reset bitset</li><li><b>const sb_t *src</b>: bitset</li><li><b>Return</b> (<i>sb_t *</i>): output bitset</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>size_t </i><b>sb_maxbitset</b>(<i>const sb_t *b</i>)<br><br><ul><li>Get position of last bit set to 1 plus 1</li><li><b>const sb_t *b</b>: bitset</li><li><b>Return</b> (<i>size_t</i>): Offset of last bit set to 1, plus 1</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>size_t </i><b>sb_popcount</b>(<i>const sb_t *b</i>)<br><br><ul><li>Number of bits set to 1</li><li><b>const sb_t *b</b>: bitset</li><li><b>Return</b> (<i>size_t</i>): Map number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>sb_test</b>(<i>const sb_t *b</i>, <i>const size_t nth</i>)<br><br><ul><li>Access to nth bit</li><li><b>const sb_t *b</b>: bitset</li><li><b>const size_t nth</b>:  bit offset</li><li><b>Return</b> (<i>int</i>): 1 or 0</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>void </i><b>sb_set</b>(<i>sb_t **b</i>, <i>const size_t nth</i>)<br><br><ul><li>Set nth bit to 1</li><li><b>sb_t **b</b>: bitset</li><li><b>const size_t nth</b>:  bit offset</li><li><b>Return</b> (<i>void</i>): O(1) with the exception of O(n) for first case of not covering unitializated areas -for real-time requirement, force set + clear at last expected writable position-</li><li><b>Time complexity:</b> 1</li><li><b>Space complexity:</b> 2</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [0/4] not reviewed</li></ul><br><br>
<i>void </i><b>sb_clear</b>(<i>sb_t **b</i>, <i>const size_t nth</i>)<br><br><ul><li>Set nth bit to 0</li><li><b>sb_t **b</b>: bitset</li><li><b>const size_t nth</b>:  bit offset</li><li><b>Return</b> (<i>void</i>): O(1)</li><li><b>Time complexity:</b> 0</li><li><b>Space complexity:</b> 1</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [0/4] not reviewed</li></ul><br><br>
</body></html>

