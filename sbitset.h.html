<!doctype html><html><title>sbitset.h:  bit set (bit array)
</title><body><h3>sbitset.h:  bit set (bit array)
</h3><br> Functions allowing bit random access storage and bit counting.
 Bit counting is optimized so, instead of per-call 'poppulation count',
 it takes O(1) for the computation, as a record of bit set/clear is
 kept.
<br><br><table><tr><th align="left">&nbsp;<a href="#sb_alloc">sb_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_clear">sb_clear</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_free">sb_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_reset">sb_reset</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_test">sb_test</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sb_alloca">sb_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_dup">sb_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_popcount">sb_popcount</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_set">sb_set</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sb_capacity">sb_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_eval">sb_eval</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_reserve">sb_reserve</a>&nbsp;</th><th align="left">&nbsp;<a href="#sb_shrink">sb_shrink</a>&nbsp;</th></tr></table><br><br><i>sb_t *</i><b><a name="sb_alloc">sb_alloc</a></b>(<i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate bitset (heap)</li><li><b>const size_t initial_num_elems_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>sb_t *</i>): bitset</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sb_t *</i><b><a name="sb_alloca">sb_alloca</a></b>(<i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate bitset (stack)</li><li><b>const size_t initial_num_elems_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>sb_t *</i>): bitset</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sb_capacity">sb_capacity</a></b>(<i>const sb_t *b</i>)<br><br><ul><li>Preallocated space left (number of 1 bit elements)</li><li><b>const sb_t *b</b>: bitset</li><li><b>Return</b> (<i>size_t</i>): allocated space left (unit: bits)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sb_clear">sb_clear</a></b>(<i>sb_t **b</i>, <i>const size_t nth</i>)<br><br><ul><li>Set nth bit to 0</li><li><b>sb_t **b</b>: bitset</li><li><b>const size_t nth</b>:  bit offset</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sb_t *</i><b><a name="sb_dup">sb_dup</a></b>(<i>const sb_t *src</i>)<br><br><ul><li>Duplicate bitset</li><li><b>const sb_t *src</b>: bitset</li><li><b>Return</b> (<i>sb_t *</i>): output bitset</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sb_eval">sb_eval</a></b>(<i>sb_t **b</i>, <i>const size_t nth</i>)<br><br><ul><li>Force evaluation of first N bits -equivalent to set to 0 all not previously referenced bits-</li><li><b>sb_t **b</b>: bitset</li><li><b>const size_t nth</b>:  bit offset</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sb_t *</i><b><a name="sb_free">sb_free</a></b>(<i>sb_t **b</i>, <i>...</i>)<br><br><ul><li>Free one or more bitsets (heap)</li><li><b>sb_t **b</b>: bitset</li><li><b>...</b>:  more bitsets (optional)</li><li><b>Return</b> (<i>sb_t *</i>): bitset</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sb_popcount">sb_popcount</a></b>(<i>const sb_t *b</i>)<br><br><ul><li>Number of bits set to 1</li><li><b>const sb_t *b</b>: bitset</li><li><b>Return</b> (<i>size_t</i>): Map number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sb_reserve">sb_reserve</a></b>(<i>sb_t **b</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Ensure space for N 1-bit elements</li><li><b>sb_t **b</b>: bitset</li><li><b>const size_t max_elems</b>: absolute element reserve (unit: bits)</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sb_t *</i><b><a name="sb_reset">sb_reset</a></b>(<i>sb_t *b</i>)<br><br><ul><li>Reset bitset</li><li><b>sb_t *b</b>: bitset</li><li><b>Return</b> (<i>sb_t *</i>): output bitset</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sb_set">sb_set</a></b>(<i>sb_t **b</i>, <i>const size_t nth</i>)<br><br><ul><li>Set nth bit to 1</li><li><b>sb_t **b</b>: bitset</li><li><b>const size_t nth</b>:  bit offset</li><li><b>Time complexity:</b> O(n) -O(1) amortized-</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sb_t *</i><b><a name="sb_shrink">sb_shrink</a></b>(<i>sb_t **b</i>)<br><br><ul><li>Free unused space</li><li><b>sb_t **b</b>: bitset</li><li><b>Return</b> (<i>sb_t *</i>): same bitset (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="sb_test">sb_test</a></b>(<i>const sb_t *b</i>, <i>const size_t nth</i>)<br><br><ul><li>Access to nth bit</li><li><b>const sb_t *b</b>: bitset</li><li><b>const size_t nth</b>:  bit offset</li><li><b>Return</b> (<i>int</i>): 1 or 0</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

