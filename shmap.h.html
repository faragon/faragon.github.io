<!doctype html><html><title>shmap.h:  hash map handling (key-value storage)
</title><body><h3>shmap.h:  hash map handling (key-value storage)
</h3><br> Map functions handle key-value storage, which is implemented as a
 hash table (O(n), with O(1) amortized time complexity for
 insert/read/delete)
<br><br> Supported key/value modes (enum eSHM_Type):
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_II32: int32_t key, int32_t value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_UU32: uint32_t key, uint32_t value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_II: int64_t key, int64_t value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_FF: float (single-precision floating point) key, float value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_DD: double (double-precision floating point) key, double value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_IS: int64_t key, string value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_IP: int64_t key, pointer value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_SI: string key, int64_t value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_DS: double key, string value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_DP: double key, pointer value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_SD: string key, double value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_SS: string key, string value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHM_SP: string key, pointer value
<br><br> Callback types for the shm_itp_*() functions:
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_ii32)(int32_t k, int32_t v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_uu32)(uint32_t k, uint32_t v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_ii)(int64_t k, int64_t v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_ff)(float k, float v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_dd)(double k, double v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_is)(int64_t k, const srt_string *, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_ip)(int64_t k, const void *, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_si)(const srt_string *, int64_t v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_ds)(double k, const srt_string *, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_dp)(double k, const void *, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_sd)(const srt_string *, double v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_ss)(const srt_string *, const srt_string *, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hmap_it_sp)(const srt_string *, const void *, void *context);
<br><br><table><tr><th align="left">&nbsp;<a href="#shm_alloca">shm_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_capacity_left">shm_capacity_left</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_dup">shm_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_ii">shm_insert_ii</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_i32_k">shm_it_i32_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_ds">shm_itp_ds</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_dd">shm_at_dd</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_clear">shm_clear</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_empty">shm_empty</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_ii32">shm_insert_ii32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_i_k">shm_it_i_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_ff">shm_itp_ff</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_dp">shm_at_dp</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_count_d">shm_count_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_free">shm_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_ip">shm_insert_ip</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_ii32_v">shm_it_ii32_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_ii">shm_itp_ii</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_ds">shm_at_ds</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_count_f">shm_count_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_grow">shm_grow</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_is">shm_insert_is</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_ii_v">shm_it_ii_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_ii32">shm_itp_ii32</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_ff">shm_at_ff</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_count_i">shm_count_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_inc_dd">shm_inc_dd</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_sd">shm_insert_sd</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_ip_v">shm_it_ip_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_ip">shm_itp_ip</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_ii">shm_at_ii</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_count_i32">shm_count_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_inc_ff">shm_inc_ff</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_si">shm_insert_si</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_is_v">shm_it_is_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_is">shm_itp_is</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_ii32">shm_at_ii32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_count_s">shm_count_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_inc_ii">shm_inc_ii</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_sp">shm_insert_sp</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_s_k">shm_it_s_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_sd">shm_itp_sd</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_ip">shm_at_ip</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_count_u32">shm_count_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_inc_ii32">shm_inc_ii32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_ss">shm_insert_ss</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_sd_v">shm_it_sd_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_si">shm_itp_si</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_is">shm_at_is</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_cpy">shm_cpy</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_inc_sd">shm_inc_sd</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_uu32">shm_insert_uu32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_si_v">shm_it_si_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_sp">shm_itp_sp</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_sd">shm_at_sd</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_delete_d">shm_delete_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_inc_si">shm_inc_si</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_d_k">shm_it_d_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_sp_v">shm_it_sp_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_ss">shm_itp_ss</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_si">shm_at_si</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_delete_f">shm_delete_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_inc_uu32">shm_inc_uu32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_dd_v">shm_it_dd_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_ss_v">shm_it_ss_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_uu32">shm_itp_uu32</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_sp">shm_at_sp</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_delete_i">shm_delete_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_dd">shm_insert_dd</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_dp_v">shm_it_dp_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_u32_k">shm_it_u32_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_max_size">shm_max_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_ss">shm_at_ss</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_delete_i32">shm_delete_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_dp">shm_insert_dp</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_ds_v">shm_it_ds_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_uu32_v">shm_it_uu32_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_reserve">shm_reserve</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_at_uu32">shm_at_uu32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_delete_s">shm_delete_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_ds">shm_insert_ds</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_f_k">shm_it_f_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_dd">shm_itp_dd</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_shrink">shm_shrink</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shm_capacity">shm_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_delete_u32">shm_delete_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_insert_ff">shm_insert_ff</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_it_ff_v">shm_it_ff_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_itp_dp">shm_itp_dp</a>&nbsp;</th><th align="left">&nbsp;<a href="#shm_size">shm_size</a>&nbsp;</th></tr></table><br><br><i>srt_hmap *</i><b><a name="shm_alloca">shm_alloca</a></b>(<i>enum eSHM_Type t</i>, <i>size_t n</i>)<br><br><ul><li>Allocate hash map (stack)</li><li><b>enum eSHM_Type t</b>: hash map type</li><li><b>size_t n</b>:  initial reserve</li><li><b>Return</b> (<i>srt_hmap *</i>): hmap</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>double </i><b><a name="shm_at_dd">shm_at_dd</a></b>(<i>const srt_hmap *hm</i>, <i>double k</i>)<br><br><ul><li>Access to element (SHM_DD)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>double</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="shm_at_dp">shm_at_dp</a></b>(<i>const srt_hmap *hm</i>, <i>double k</i>)<br><br><ul><li>Access to element (SHM_DP)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>const void *</i>): value pointer</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>const srt_string *</i><b><a name="shm_at_ds">shm_at_ds</a></b>(<i>const srt_hmap *hm</i>, <i>double k</i>)<br><br><ul><li>Access to element (SHM_DS)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>const srt_string *</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>float </i><b><a name="shm_at_ff">shm_at_ff</a></b>(<i>const srt_hmap *hm</i>, <i>float k</i>)<br><br><ul><li>Access to element (SHM_FF)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>float k</b>:  key</li><li><b>Return</b> (<i>float</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="shm_at_ii">shm_at_ii</a></b>(<i>const srt_hmap *hm</i>, <i>int64_t k</i>)<br><br><ul><li>Access to element (SHM_II)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>int64_t</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="shm_at_ii32">shm_at_ii32</a></b>(<i>const srt_hmap *hm</i>, <i>int32_t k</i>)<br><br><ul><li>Access to element (SHM_II32)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>int32_t k</b>:  key</li><li><b>Return</b> (<i>int32_t</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="shm_at_ip">shm_at_ip</a></b>(<i>const srt_hmap *hm</i>, <i>int64_t k</i>)<br><br><ul><li>Access to element (SHM_IP)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>const void *</i>): value pointer</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>const srt_string *</i><b><a name="shm_at_is">shm_at_is</a></b>(<i>const srt_hmap *hm</i>, <i>int64_t k</i>)<br><br><ul><li>Access to element (SHM_IS)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>const srt_string *</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>double </i><b><a name="shm_at_sd">shm_at_sd</a></b>(<i>const srt_hmap *hm</i>, <i>const srt_string *k</i>)<br><br><ul><li>Access to element (SHM_SD)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>double</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>int64_t </i><b><a name="shm_at_si">shm_at_si</a></b>(<i>const srt_hmap *hm</i>, <i>const srt_string *k</i>)<br><br><ul><li>Access to element (SHM_SI)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>int64_t</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>const void *</i><b><a name="shm_at_sp">shm_at_sp</a></b>(<i>const srt_hmap *hm</i>, <i>const srt_string *k</i>)<br><br><ul><li>Access to element (SHM_SP)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>const void *</i>): value pointer</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="shm_at_ss">shm_at_ss</a></b>(<i>const srt_hmap *hm</i>, <i>const srt_string *k</i>)<br><br><ul><li>Access to element (SHM_SS)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>const srt_string *</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="shm_at_uu32">shm_at_uu32</a></b>(<i>const srt_hmap *hm</i>, <i>uint32_t k</i>)<br><br><ul><li>Access to element (SHM_UU32)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>uint32_t k</b>:  key</li><li><b>Return</b> (<i>uint32_t</i>): value</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_capacity">shm_capacity</a></b>(<i>const srt_hmap *hm</i>)<br><br><ul><li>Allocated space</li><li><b>const srt_hmap *hm</b>: hmap</li><li><b>Return</b> (<i>size_t</i>): current allocated space (vector elements)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_capacity_left">shm_capacity_left</a></b>(<i>const srt_hmap *hm</i>)<br><br><ul><li>Preallocated space left</li><li><b>const srt_hmap *hm</b>: hmap</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="shm_clear">shm_clear</a></b>(<i>srt_hmap *hm</i>)<br><br><ul><li>Clear/reset map (keeping map type)</li><li><b>srt_hmap *hm</b>: hmap</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>size_t </i><b><a name="shm_count_d">shm_count_d</a></b>(<i>const srt_hmap *hm</i>, <i>double k</i>)<br><br><ul><li>Map element count/check (SHM_D*)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_count_f">shm_count_f</a></b>(<i>const srt_hmap *hm</i>, <i>float k</i>)<br><br><ul><li>Map element count/check (SHM_FF)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>float k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_count_i">shm_count_i</a></b>(<i>const srt_hmap *hm</i>, <i>int64_t k</i>)<br><br><ul><li>Map element count/check (SHM_I*)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_count_i32">shm_count_i32</a></b>(<i>const srt_hmap *hm</i>, <i>int32_t k</i>)<br><br><ul><li>Map element count/checks (SHM_II32)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>int32_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_count_s">shm_count_s</a></b>(<i>const srt_hmap *hm</i>, <i>const srt_string *k</i>)<br><br><ul><li>Map element count/check (SHM_S*)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_count_u32">shm_count_u32</a></b>(<i>const srt_hmap *hm</i>, <i>uint32_t k</i>)<br><br><ul><li>Map element count/check (SHM_UU32)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>uint32_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_hmap *</i><b><a name="shm_cpy">shm_cpy</a></b>(<i>srt_hmap **hm</i>, <i>const srt_hmap *src</i>)<br><br><ul><li>Overwrite map with a map copy</li><li><b>srt_hmap **hm</b>: output hash map</li><li><b>const srt_hmap *src</b>:  input map</li><li><b>Return</b> (<i>srt_hmap *</i>): output map reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_delete_d">shm_delete_d</a></b>(<i>srt_hmap *hm</i>, <i>double k</i>)<br><br><ul><li>Delete map element (SHM_D*)</li><li><b>srt_hmap *hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_delete_f">shm_delete_f</a></b>(<i>srt_hmap *hm</i>, <i>float k</i>)<br><br><ul><li>Delete map element (SHM_FF)</li><li><b>srt_hmap *hm</b>: hash map</li><li><b>float k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_delete_i">shm_delete_i</a></b>(<i>srt_hmap *hm</i>, <i>int64_t k</i>)<br><br><ul><li>Delete map element (SHM_I*)</li><li><b>srt_hmap *hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_delete_i32">shm_delete_i32</a></b>(<i>srt_hmap *hm</i>, <i>int32_t k</i>)<br><br><ul><li>Delete map element (SHM_II32)</li><li><b>srt_hmap *hm</b>: hash map</li><li><b>int32_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_delete_s">shm_delete_s</a></b>(<i>srt_hmap *hm</i>, <i>const srt_string *k</i>)<br><br><ul><li>Delete map element (SHM_S*)</li><li><b>srt_hmap *hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_delete_u32">shm_delete_u32</a></b>(<i>srt_hmap *hm</i>, <i>uint32_t k</i>)<br><br><ul><li>Delete map element (SHM_UU32)</li><li><b>srt_hmap *hm</b>: hash map</li><li><b>uint32_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_hmap *</i><b><a name="shm_dup">shm_dup</a></b>(<i>const srt_hmap *src</i>)<br><br><ul><li>Duplicate hash map</li><li><b>const srt_hmap *src</b>: input map</li><li><b>Return</b> (<i>srt_hmap *</i>): output map</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_empty">shm_empty</a></b>(<i>const srt_hmap *hm</i>)<br><br><ul><li>Tells if a hash map is empty (zero elements)</li><li><b>const srt_hmap *hm</b>: hmap</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: empty; S_FALSE: not empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="shm_free">shm_free</a></b>(<i>srt_hmap **hm</i>, <i>...</i>)<br><br><ul><li>Free one or more hash maps</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>...</b>:  more hash maps (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple dmaps, O(n) for dmaps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_grow">shm_grow</a></b>(<i>srt_hmap **hm</i>, <i>size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>size_t extra_elems</b>: number of extra elements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_inc_dd">shm_inc_dd</a></b>(<i>srt_hmap **hm</i>, <i>double k</i>, <i>double v</i>)<br><br><ul><li>Increment map element (SHM_DD)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>double v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_inc_ff">shm_inc_ff</a></b>(<i>srt_hmap **hm</i>, <i>float k</i>, <i>float v</i>)<br><br><ul><li>Increment map element (SHM_FF)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>float k</b>:  key</li><li><b>float v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_inc_ii">shm_inc_ii</a></b>(<i>srt_hmap **hm</i>, <i>int64_t k</i>, <i>int64_t v</i>)<br><br><ul><li>Increment map element (SHM_II)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>int64_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_inc_ii32">shm_inc_ii32</a></b>(<i>srt_hmap **hm</i>, <i>int32_t k</i>, <i>int32_t v</i>)<br><br><ul><li>Increment value map element (SHM_II32)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>int32_t k</b>:  key</li><li><b>int32_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_inc_sd">shm_inc_sd</a></b>(<i>srt_hmap **hm</i>, <i>const srt_string *k</i>, <i>double v</i>)<br><br><ul><li>Increment map element (SHM_SD)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>double v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_inc_si">shm_inc_si</a></b>(<i>srt_hmap **hm</i>, <i>const srt_string *k</i>, <i>int64_t v</i>)<br><br><ul><li>Increment map element (SHM_SI)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>int64_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_inc_uu32">shm_inc_uu32</a></b>(<i>srt_hmap **hm</i>, <i>uint32_t k</i>, <i>uint32_t v</i>)<br><br><ul><li>Increment map element (SHM_UU32)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>uint32_t k</b>:  key</li><li><b>uint32_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_dd">shm_insert_dd</a></b>(<i>srt_hmap **hm</i>, <i>double k</i>, <i>double v</i>)<br><br><ul><li>Insert into map (SHM_DD)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>double v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_dp">shm_insert_dp</a></b>(<i>srt_hmap **hm</i>, <i>double k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into map (SHM_DP)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_ds">shm_insert_ds</a></b>(<i>srt_hmap **hm</i>, <i>double k</i>, <i>const srt_string *v</i>)<br><br><ul><li>Insert into map (SHM_DS)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>double k</b>:  key</li><li><b>const srt_string *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_ff">shm_insert_ff</a></b>(<i>srt_hmap **hm</i>, <i>float k</i>, <i>float v</i>)<br><br><ul><li>Insert into map (SHM_FF)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>float k</b>:  key</li><li><b>float v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_ii">shm_insert_ii</a></b>(<i>srt_hmap **hm</i>, <i>int64_t k</i>, <i>int64_t v</i>)<br><br><ul><li>Insert into map (SHM_II)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>int64_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_ii32">shm_insert_ii32</a></b>(<i>srt_hmap **hm</i>, <i>int32_t k</i>, <i>int32_t v</i>)<br><br><ul><li>Insert into map (SHM_II32)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>int32_t k</b>:  key</li><li><b>int32_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_ip">shm_insert_ip</a></b>(<i>srt_hmap **hm</i>, <i>int64_t k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into map (SHM_IP)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_is">shm_insert_is</a></b>(<i>srt_hmap **hm</i>, <i>int64_t k</i>, <i>const srt_string *v</i>)<br><br><ul><li>Insert into map (SHM_IS)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>int64_t k</b>:  key</li><li><b>const srt_string *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_sd">shm_insert_sd</a></b>(<i>srt_hmap **hm</i>, <i>const srt_string *k</i>, <i>double v</i>)<br><br><ul><li>Insert into map (SHM_SD)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>double v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_si">shm_insert_si</a></b>(<i>srt_hmap **hm</i>, <i>const srt_string *k</i>, <i>int64_t v</i>)<br><br><ul><li>Insert into map (SHM_SI)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>int64_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_sp">shm_insert_sp</a></b>(<i>srt_hmap **hm</i>, <i>const srt_string *k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into map (SHM_SP)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_ss">shm_insert_ss</a></b>(<i>srt_hmap **hm</i>, <i>const srt_string *k</i>, <i>const srt_string *v</i>)<br><br><ul><li>Insert into map (SHM_SS)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>const srt_string *k</b>:  key</li><li><b>const srt_string *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shm_insert_uu32">shm_insert_uu32</a></b>(<i>srt_hmap **hm</i>, <i>uint32_t k</i>, <i>uint32_t v</i>)<br><br><ul><li>Insert into map (SHM_UU32)</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>uint32_t k</b>:  key</li><li><b>uint32_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>double </i><b><a name="shm_it_d_k">shm_it_d_k</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map keys (SHM_D*)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>double</i>): double</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>double </i><b><a name="shm_it_dd_v">shm_it_dd_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_DD)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>double</i>): double</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="shm_it_dp_v">shm_it_dp_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_DP)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const void *</i>): double</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="shm_it_ds_v">shm_it_ds_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_DS)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const srt_string *</i>): double</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>float </i><b><a name="shm_it_f_k">shm_it_f_k</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map keys (SHM_FF)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>float</i>): float</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>float </i><b><a name="shm_it_ff_v">shm_it_ff_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_FF)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>float</i>): float</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="shm_it_i32_k">shm_it_i32_k</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map keys (SHM_II32)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int32_t</i>): int32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="shm_it_i_k">shm_it_i_k</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map keys (SHM_I*)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int64_t</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="shm_it_ii32_v">shm_it_ii32_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_II32)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int32_t</i>): int32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="shm_it_ii_v">shm_it_ii_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_II)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int64_t</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="shm_it_ip_v">shm_it_ip_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_IP)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="shm_it_is_v">shm_it_is_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_IS)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="shm_it_s_k">shm_it_s_k</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map keys (SHM_S*)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>double </i><b><a name="shm_it_sd_v">shm_it_sd_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_SD)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>double</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="shm_it_si_v">shm_it_si_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_SI)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int64_t</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="shm_it_sp_v">shm_it_sp_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map (SHM_SP)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="shm_it_ss_v">shm_it_ss_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_SS)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="shm_it_u32_k">shm_it_u32_k</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map keys (SHM_UU32)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>uint32_t</i>): uint32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="shm_it_uu32_v">shm_it_uu32_v</a></b>(<i>const srt_hmap *hm</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate map values (SHM_UU32)</li><li><b>const srt_hmap *hm</b>: hash map</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>uint32_t</i>): uint32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_dd">shm_itp_dd</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_dd f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_DD)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_dd f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_dp">shm_itp_dp</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_dp f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_DP)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_dp f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_ds">shm_itp_ds</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_ds f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_DS)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_ds f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_ff">shm_itp_ff</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_ff f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_FF)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_ff f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_ii">shm_itp_ii</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_ii f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_II)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_ii f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_ii32">shm_itp_ii32</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_ii32 f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_II32)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_ii32 f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_ip">shm_itp_ip</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_ip f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_IP)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_ip f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_is">shm_itp_is</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_is f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_IS)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_is f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_sd">shm_itp_sd</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_sd f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_SD)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_sd f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_si">shm_itp_si</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_si f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_SI)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_si f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_sp">shm_itp_sp</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_sp f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_SP)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_sp f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_ss">shm_itp_ss</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_ss f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_SS)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_ss f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_itp_uu32">shm_itp_uu32</a></b>(<i>const srt_hmap *m</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hmap_it_uu32 f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in portions (SHM_UU32)</li><li><b>const srt_hmap *m</b>: map</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hmap_it_uu32 f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_max_size">shm_max_size</a></b>(<i>const srt_hmap *hm</i>)<br><br><ul><li>Get hmap size</li><li><b>const srt_hmap *hm</b>: hmap</li><li><b>Return</b> (<i>size_t</i>): Hash map current max number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_reserve">shm_reserve</a></b>(<i>srt_hmap **hm</i>, <i>size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>srt_hmap **hm</b>: hash map</li><li><b>size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_hmap *</i><b><a name="shm_shrink">shm_shrink</a></b>(<i>srt_hmap **hm</i>)<br><br><ul><li>Make the hmap use the minimum possible memory</li><li><b>srt_hmap **hm</b>: hmap</li><li><b>Return</b> (<i>srt_hmap *</i>): hmap reference (optional usage)</li><li><b>Time complexity:</b> O(1) for allocators using memory remap</li><li><b>Space complexity:</b> O(n) for naive allocators</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shm_size">shm_size</a></b>(<i>const srt_hmap *hm</i>)<br><br><ul><li>Get hmap size</li><li><b>const srt_hmap *hm</b>: hmap</li><li><b>Return</b> (<i>size_t</i>): Hash map number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

