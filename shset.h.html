<!doctype html><html><title>shset.h:  hash set handling (key-only storage)
</title><body><h3>shset.h:  hash set handling (key-only storage)
</h3><br> Set functions handle key-only storage, which is implemented as a
 hash table (O(n), with O(1) amortized time complexity for insert/
 count/delete).
<br><br> Supported set modes (enum eSHS_Type):
<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHS_I32: int32_t key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHS_U32: uint32_t key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHS_I: int64_t key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHS_F: float (single-precision floating point) key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHS_D: double (double-precision floating point) key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHS_S: string key
<br><br> Callback types for the shs_itp_*() functions:
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hset_it_i32)(int32_t k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hset_it_u32)(uint32_t k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hset_it_i)(int64_t k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hset_it_f)(float k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hset_it_d)(double k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_hset_it_s)(const srt_string *, void *context);
<br><br><table><tr><th align="left">&nbsp;<a href="#shs_alloc">shs_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_count_i32">shs_count_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_delete_s">shs_delete_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_insert_i">shs_insert_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_it_s">shs_it_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_max_size">shs_max_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shs_alloca">shs_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_count_s">shs_count_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_delete_u32">shs_delete_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_insert_i32">shs_insert_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_it_u32">shs_it_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_reserve">shs_reserve</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shs_capacity">shs_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_count_u32">shs_count_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_dup">shs_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_insert_s">shs_insert_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_itp_d">shs_itp_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_shrink">shs_shrink</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shs_capacity_left">shs_capacity_left</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_cpy">shs_cpy</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_empty">shs_empty</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_insert_u32">shs_insert_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_itp_f">shs_itp_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_size">shs_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shs_clear">shs_clear</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_delete_d">shs_delete_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_free">shs_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_it_d">shs_it_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_itp_i">shs_itp_i</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shs_count_d">shs_count_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_delete_f">shs_delete_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_grow">shs_grow</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_it_f">shs_it_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_itp_i32">shs_itp_i32</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shs_count_f">shs_count_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_delete_i">shs_delete_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_insert_d">shs_insert_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_it_i">shs_it_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_itp_s">shs_itp_s</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#shs_count_i">shs_count_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_delete_i32">shs_delete_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_insert_f">shs_insert_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_it_i32">shs_it_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#shs_itp_u32">shs_itp_u32</a>&nbsp;</th></tr></table><br><br><i>srt_hset *</i><b><a name="shs_alloc">shs_alloc</a></b>(<i>enum eSHS_Type t</i>, <i>size_t init_size</i>)<br><br><ul><li>Allocate hash set (heap)</li><li><b>enum eSHS_Type t</b>: set type</li><li><b>size_t init_size</b>:  initial reserve</li><li><b>Return</b> (<i>srt_hset *</i>): hash set</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_hset *</i><b><a name="shs_alloca">shs_alloca</a></b>(<i>enum eSHS_Type t</i>, <i>size_t n</i>)<br><br><ul><li>Allocate hash set (stack)</li><li><b>enum eSHS_Type t</b>: set type</li><li><b>size_t n</b>:  initial reserve</li><li><b>Return</b> (<i>srt_hset *</i>): map</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_capacity">shs_capacity</a></b>(<i>const srt_hset *hs</i>)<br><br><ul><li>Allocated space</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>Return</b> (<i>size_t</i>): current allocated space (vector elements)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_capacity_left">shs_capacity_left</a></b>(<i>const srt_hset *hs</i>)<br><br><ul><li>Preallocated space left</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="shs_clear">shs_clear</a></b>(<i>srt_hset *hs</i>)<br><br><ul><li>Clear/reset map (keeping map type)</li><li><b>srt_hset *hs</b>: hash set</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_count_d">shs_count_d</a></b>(<i>const srt_hset *hs</i>, <i>double k</i>)<br><br><ul><li>Map element count/check (SHS_D)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the hash set </li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_count_f">shs_count_f</a></b>(<i>const srt_hset *hs</i>, <i>float k</i>)<br><br><ul><li>Map element count/check (SHS_F)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>float k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the hash set </li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_count_i">shs_count_i</a></b>(<i>const srt_hset *hs</i>, <i>int64_t k</i>)<br><br><ul><li>Map element count/check (SHS_I)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the hash set </li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_count_i32">shs_count_i32</a></b>(<i>const srt_hset *hs</i>, <i>int32_t k</i>)<br><br><ul><li>Map element count/check (SHS_I32)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>int32_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the hash set </li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_count_s">shs_count_s</a></b>(<i>const srt_hset *hs</i>, <i>const srt_string *k</i>)<br><br><ul><li>Map element count/check (SHS_S)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the hash set </li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_count_u32">shs_count_u32</a></b>(<i>const srt_hset *hs</i>, <i>uint32_t k</i>)<br><br><ul><li>Map element count/check (SHS_U32)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>uint32_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the hash set </li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_hset *</i><b><a name="shs_cpy">shs_cpy</a></b>(<i>srt_hset **hs</i>, <i>const srt_hset *src</i>)<br><br><ul><li>Overwrite map with a map copy</li><li><b>srt_hset **hs</b>: output map</li><li><b>const srt_hset *src</b>:  input hash setoutput map reference (optional usage)</li><li><b>Return</b> (<i>srt_hset *</i>): O(n)</li><li><b>Time complexity:</b> 1</li><li><b>Space complexity:</b> 2</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [0/4] not reviewed</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_delete_d">shs_delete_d</a></b>(<i>srt_hset *hs</i>, <i>double k</i>)<br><br><ul><li>Delete map element (SHS_D)</li><li><b>srt_hset *hs</b>: hash set</li><li><b>double k</b>:  double key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_delete_f">shs_delete_f</a></b>(<i>srt_hset *hs</i>, <i>float k</i>)<br><br><ul><li>Delete map element (SHS_F)</li><li><b>srt_hset *hs</b>: hash set</li><li><b>float k</b>:  float key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_delete_i">shs_delete_i</a></b>(<i>srt_hset *hs</i>, <i>int64_t k</i>)<br><br><ul><li>Delete map element (SHS_I)</li><li><b>srt_hset *hs</b>: hash set</li><li><b>int64_t k</b>:  int64_t key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_delete_i32">shs_delete_i32</a></b>(<i>srt_hset *hs</i>, <i>int32_t k</i>)<br><br><ul><li>Delete map element (SHS_I32)</li><li><b>srt_hset *hs</b>: hash set</li><li><b>int32_t k</b>:  int32_t key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_delete_s">shs_delete_s</a></b>(<i>srt_hset *hs</i>, <i>const srt_string *k</i>)<br><br><ul><li>Delete map element (SHS_S)</li><li><b>srt_hset *hs</b>: hash set</li><li><b>const srt_string *k</b>:  string key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_delete_u32">shs_delete_u32</a></b>(<i>srt_hset *hs</i>, <i>uint32_t k</i>)<br><br><ul><li>Delete map element (SHS_U32)</li><li><b>srt_hset *hs</b>: hash set</li><li><b>uint32_t k</b>:  int32_t key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_hset *</i><b><a name="shs_dup">shs_dup</a></b>(<i>const srt_hset *src</i>)<br><br><ul><li>Duplicate hash set</li><li><b>const srt_hset *src</b>: input hash setoutput hash set</li><li><b>Return</b> (<i>srt_hset *</i>): O(n)</li><li><b>Time complexity:</b> 1</li><li><b>Space complexity:</b> 2</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [0/4] not reviewed</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_empty">shs_empty</a></b>(<i>const srt_hset *hs</i>)<br><br><ul><li>Tells if a hash set is empty (zero elements)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: empty; S_FALSE: not empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="shs_free">shs_free</a></b>(<i>srt_hset **hs</i>, <i>...</i>)<br><br><ul><li>Free one or more hash sets</li><li><b>srt_hset **hs</b>: hash set</li><li><b>...</b>:  more hash sets (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple dmaps, O(n) for dmaps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_grow">shs_grow</a></b>(<i>srt_hset **hs</i>, <i>size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>srt_hset **hs</b>: hash set</li><li><b>size_t extra_elems</b>: number of extra elements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_insert_d">shs_insert_d</a></b>(<i>srt_hset **hs</i>, <i>double k</i>)<br><br><ul><li>Insert into hash set (SHS_D)</li><li><b>srt_hset **hs</b>: hash set</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_insert_f">shs_insert_f</a></b>(<i>srt_hset **hs</i>, <i>float k</i>)<br><br><ul><li>Insert into hash set (SHS_F)</li><li><b>srt_hset **hs</b>: hash set</li><li><b>float k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_insert_i">shs_insert_i</a></b>(<i>srt_hset **hs</i>, <i>int64_t k</i>)<br><br><ul><li>Insert into hash set (SHS_I)</li><li><b>srt_hset **hs</b>: hash set</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_insert_i32">shs_insert_i32</a></b>(<i>srt_hset **hs</i>, <i>int32_t k</i>)<br><br><ul><li>Insert into hash set (SHS_I32)</li><li><b>srt_hset **hs</b>: hash set</li><li><b>int32_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_insert_s">shs_insert_s</a></b>(<i>srt_hset **hs</i>, <i>const srt_string *k</i>)<br><br><ul><li>Insert into hash set (SHS_S)</li><li><b>srt_hset **hs</b>: hash set</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="shs_insert_u32">shs_insert_u32</a></b>(<i>srt_hset **hs</i>, <i>uint32_t k</i>)<br><br><ul><li>Insert into hash set (SHS_U32)</li><li><b>srt_hset **hs</b>: hash set</li><li><b>uint32_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(n), O(1) average amortized</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>double </i><b><a name="shs_it_d">shs_it_d</a></b>(<i>const srt_hset *hs</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate set keys (SHS_D)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>double</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>float </i><b><a name="shs_it_f">shs_it_f</a></b>(<i>const srt_hset *hs</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate set keys (SHS_F)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>float</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>int64_t </i><b><a name="shs_it_i">shs_it_i</a></b>(<i>const srt_hset *hs</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate set keys (SHS_I)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int64_t</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="shs_it_i32">shs_it_i32</a></b>(<i>const srt_hset *hs</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate set keys (SHS_I32)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int32_t</i>): int32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="shs_it_s">shs_it_s</a></b>(<i>const srt_hset *hs</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate set keys (SHS_S)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="shs_it_u32">shs_it_u32</a></b>(<i>const srt_hset *hs</i>, <i>size_t i</i>)<br><br><ul><li>Enumerate set keys (SHS_U32)</li><li><b>const srt_hset *hs</b>: hash set</li><li><b>size_t i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>uint32_t</i>): uint32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_itp_d">shs_itp_d</a></b>(<i>const srt_hset *s</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hset_it_d f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate set elements in portions (SHS_D)</li><li><b>const srt_hset *s</b>: set</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hset_it_d f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_itp_f">shs_itp_f</a></b>(<i>const srt_hset *s</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hset_it_f f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate set elements in portions (SHS_F)</li><li><b>const srt_hset *s</b>: set</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hset_it_f f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_itp_i">shs_itp_i</a></b>(<i>const srt_hset *s</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hset_it_i f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate set elements in portions (SHS_I)</li><li><b>const srt_hset *s</b>: set</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hset_it_i f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_itp_i32">shs_itp_i32</a></b>(<i>const srt_hset *s</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hset_it_i32 f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate set elements in portions (SHS_I32)</li><li><b>const srt_hset *s</b>: set</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hset_it_i32 f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_itp_s">shs_itp_s</a></b>(<i>const srt_hset *s</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hset_it_s f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate set elements in portions (SHS_S)</li><li><b>const srt_hset *s</b>: set</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hset_it_s f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_itp_u32">shs_itp_u32</a></b>(<i>const srt_hset *s</i>, <i>size_t begin</i>, <i>size_t end</i>, <i>srt_hset_it_u32 f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate set elements in portions (SHS_U32)</li><li><b>const srt_hset *s</b>: set</li><li><b>size_t begin</b>:  index start</li><li><b>size_t end</b>:  index end</li><li><b>srt_hset_it_u32 f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_max_size">shs_max_size</a></b>(<i>const srt_hset *hs</i>)<br><br><ul><li>Get hmap size</li><li><b>const srt_hset *hs</b>: map</li><li><b>Return</b> (<i>size_t</i>): hash set current max number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_reserve">shs_reserve</a></b>(<i>srt_hset **hs</i>, <i>size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>srt_hset **hs</b>: hash set</li><li><b>size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_hset *</i><b><a name="shs_shrink">shs_shrink</a></b>(<i>srt_hset **hs</i>)<br><br><ul><li>Make the hmap use the minimum possible memory</li><li><b>srt_hset **hs</b>: hash set</li><li><b>Return</b> (<i>srt_hset *</i>): hash set reference (optional usage)</li><li><b>Time complexity:</b> O(1) for allocators using memory remap</li><li><b>Space complexity:</b> O(n) for naive allocators</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="shs_size">shs_size</a></b>(<i>const srt_hset *hs</i>)<br><br><ul><li>Get hmap size</li><li><b>const srt_hset *hs</b>: map</li><li><b>Return</b> (<i>size_t</i>): hash set number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

