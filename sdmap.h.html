<!doctype html><html><title>sdmap.h:  distributed map (same-process map clustering/slicing)
</title><body><h3>sdmap.h:  distributed map (same-process map clustering/slicing)
</h3><br> Following functions allow map partition, so e.g. you could divide
 a logical big map into N instances, while operating against the
 logical map like simple map.
<br><br><table><tr><th align="left">&nbsp;<a href="#sdm_alloc">sdm_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_free">sdm_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_reset">sdm_reset</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_set_routing">sdm_set_routing</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_size">sdm_size</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_submaps_r">sdm_submaps_r</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sdm_dup">sdm_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_i_route">sdm_i_route</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_s_route">sdm_s_route</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_shrink">sdm_shrink</a>&nbsp;</th><th align="left">&nbsp;<a href="#sdm_submaps">sdm_submaps</a>&nbsp;</th></tr></table><br><br><i>sdm_t *</i><b><a name="sdm_alloc">sdm_alloc</a></b>(<i>const enum eSM_Type t</i>, <i>const size_t number_of_submaps</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate distributed map (heap)</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>const size_t number_of_submaps</b>:  number of submaps</li><li><b>const size_t initial_num_elems_reserve</b>:  initial reserve</li><li><b>Return</b> (<i>sdm_t *</i>): map</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sdm_t *</i><b><a name="sdm_dup">sdm_dup</a></b>(<i>const sdm_t *src</i>)<br><br><ul><li>Duplicate distributed map</li><li><b>const sdm_t *src</b>: input map</li><li><b>Return</b> (<i>sdm_t *</i>): output map</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sdm_free">sdm_free</a></b>(<i>sdm_t **dm</i>, <i>...</i>)<br><br><ul><li>Free one or more distributed maps</li><li><b>sdm_t **dm</b>: map</li><li><b>...</b>:  more distributed maps (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple dmaps, O(n) for dmaps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sdm_i_route">sdm_i_route</a></b>(<i>const sdm_t *dm</i>, <i>const int64_t k</i>)<br><br><ul><li>Get route to subtree (integer key)</li><li><b>const sdm_t *dm</b>: dmap</li><li><b>const int64_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): subtree id</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sdm_reset">sdm_reset</a></b>(<i>sdm_t *m</i>)<br><br><ul><li>Reset/clean distributed map (keeping map type)</li><li><b>sdm_t *m</b>: map</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: invalid map</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sdm_s_route">sdm_s_route</a></b>(<i>const sdm_t *dm</i>, <i>const ss_t *k</i>)<br><br><ul><li>Get route to subtree (string key)</li><li><b>const sdm_t *dm</b>: dmap</li><li><b>const ss_t *k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): subtree id</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sdm_set_routing">sdm_set_routing</a></b>(<i>sdm_t *dm</i>, <i>sdm_i_hash_t irf</i>, <i>sdm_s_hash_t srf</i>)<br><br><ul><li>Set routing functions</li><li><b>sdm_t *dm</b>: map</li><li><b>sdm_i_hash_t irf</b>:  routing function for integer keys (if NULL, a "fair" hash will be used)</li><li><b>sdm_s_hash_t srf</b>:  routing function for string keys (if NULL, also a "fair" hash will be used)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sdm_shrink">sdm_shrink</a></b>(<i>sdm_t **s</i>)<br><br><ul><li>Make the dynamic map use the minimum possible memory</li><li><b>sdm_t **s</b>: map</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for allocators using memory remap</li><li><b>Space complexity:</b> O(n) for naive allocators</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sdm_size">sdm_size</a></b>(<i>const sdm_t *m</i>)<br><br><ul><li>Get number of submaps</li><li><b>const sdm_t *m</b>: dmap</li><li><b>Return</b> (<i>size_t</i>): Number of submaps</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sm_t **</i><b><a name="sdm_submaps">sdm_submaps</a></b>(<i>sdm_t *m</i>)<br><br><ul><li>Get submap pointer vector</li><li><b>sdm_t *m</b>: dmap</li><li><b>Return</b> (<i>sm_t **</i>): map vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const sm_t **</i><b><a name="sdm_submaps_r">sdm_submaps_r</a></b>(<i>const sdm_t *m</i>)<br><br><ul><li>Get submap pointer vector (read-only)</li><li><b>const sdm_t *m</b>: dmap</li><li><b>Return</b> (<i>const sm_t **</i>): map vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

