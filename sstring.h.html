<!doctype html><html><body><h3>Documentation for sstring.h</h3><br><i>void </i><b>ss_free</b>(<i>ss_t **c</i>, <i>...</i>)<br><br><ul><li>Free one or more strings (heap)</li><li><b>ss_t **c</b>: string</li><li><b>...</b>: more strings (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_grow</b>(<i>ss_t **c</i>, <i>const size_t extra_elems</i>)<br><br><ul><li>Reserve space for extra elements (relative to current string size)</li><li><b>ss_t **c</b>: string</li><li><b>const size_t extra_elems</b>: number of extra elements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_reserve</b>(<i>ss_t **c</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Reserve space for at least N bytes (absolute reserve)</li><li><b>ss_t **c</b>: string</li><li><b>const size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_shrink</b>(<i>ss_t **c</i>)<br><br><ul><li>Free unused space</li><li><b>ss_t **c</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): same string (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_size</b>(<i>const ss_t *c</i>)<br><br><ul><li>Get string size</li><li><b>const ss_t *c</b>: string</li><li><b>Return</b> (<i>size_t</i>): string bytes used in UTF8 format</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>void </i><b>ss_set_size</b>(<i>ss_t *c</i>, <i>const size_t s</i>)<br><br><ul><li>Set string size (bytes used in UTF8 format)</li><li><b>ss_t *c</b>: string</li><li><b>const size_t s</b>: new size</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>size_t </i><b>ss_len</b>(<i>const ss_t *c</i>)<br><br><ul><li>Equivalent to ss_size</li><li><b>const ss_t *c</b>: string</li><li><b>Return</b> (<i>size_t</i>): Number of bytes (UTF-8 string length)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_alloc</b>(<i>const size_t initial_heap_reserve</i>)<br><br><ul><li>Allocate string (heap)</li><li><b>const size_t initial_heap_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>ss_t *</i>): allocated string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_alloca</b>(<i>const size_t initial_reserve</i>)<br><br><ul><li>Allocate string (stack)</li><li><b>const size_t initial_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>ss_t *</i>): allocated string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_len_u</b>(<i>ss_t *s</i>)<br><br><ul><li>String length (Unicode)</li><li><b>ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): number of Unicode characters</li><li><b>Time complexity:</b> O(1) if cached, O(n) if not previously computed</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_capacity</b>(<i>const ss_t *s</i>)<br><br><ul><li>Allocated space</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): current allocated space (bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_len_left</b>(<i>const ss_t *s</i>)<br><br><ul><li>Preallocated space left</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_max</b>(<i>const ss_t *s</i>)<br><br><ul><li>Get the maximum possible string size</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): max string size (bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b>ss_set_len</b>(<i>ss_t *s</i>, <i>const size_t bytes_in_use</i>)<br><br><ul><li>Explicit set length (intended for external I/O raw acccess)</li><li><b>ss_t *s</b>: string</li><li><b>const size_t bytes_in_use</b>: new length</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>char *</i><b>ss_get_buffer</b>(<i>ss_t *s</i>)<br><br><ul><li>Get string buffer access</li><li><b>ss_t *s</b>: string</li><li><b>Return</b> (<i>char *</i>): pointer to the insternal string buffer (UTF-8 or raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>ss_alloc_errors</b>(<i>const ss_t *s</i>)<br><br><ul><li>Check if string had allocation errors</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: has errors; S_FALSE: no errors</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>ss_encoding_errors</b>(<i>const ss_t *s</i>)<br><br><ul><li>Check if string had UTF8 encoding errors</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: has errors; S_FALSE: no errors</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>void </i><b>ss_clear_errors</b>(<i>ss_t *s</i>)<br><br><ul><li>Clear allocation/encoding error flags</li><li><b>ss_t *s</b>: string</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_dup</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): Output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_sub</b>(<i>const ss_t *src</i>, <i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Duplicate from substring</li><li><b>const ss_t *src</b>: string</li><li><b>const sv_t *offsets</b>: substring offsets</li><li><b>const size_t nth</b>: select nth substring</li><li><b>Return</b> (<i>ss_t *</i>): Output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_substr</b>(<i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from substring</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t off</b>: byte offset</li><li><b>const size_t n</b>: number of bytes</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_substr_u</b>(<i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from substring</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t char_off</b>: character offset</li><li><b>const size_t n</b>: number of characters</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_cn</b>(<i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Duplicate from C string</li><li><b>const char *src</b>: C string buffer</li><li><b>const size_t src_size</b>: number of bytes</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_c</b>(<i>const char *src</i>)<br><br><ul><li>Duplicate from C String (ASCII-z)</li><li><b>const char *src</b>: C string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_wn</b>(<i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Duplicate from Unicode "wide char" string</li><li><b>const wchar_t *src</b>: "wide char" string</li><li><b>const size_t src_size</b>:  number of characters</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_w</b>(<i>const wchar_t *src</i>)<br><br><ul><li>Duplicate from "wide char" Unicode string</li><li><b>const wchar_t *src</b>: "wide char" string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_int</b>(<i>const sint_t num</i>)<br><br><ul><li>Duplicate from integer</li><li><b>const sint_t num</b>: integer</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_tolower</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with lowercase conversion</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_toupper</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with uppercase conversion</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_enc_b64</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with base64 encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_enc_hex</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with hex encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_enc_HEX</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with hex encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_enc_esc_json</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with JSON escape encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_enc_esc_xml</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with XML escape encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_enc_esc_url</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with URL escape encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_enc_esc_dquote</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string escaping " as ""</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_enc_esc_squote</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string escaping ' as ''</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_dec_b64</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with base64 decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_dec_hex</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with hex decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_dec_esc_json</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with JSON escape decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_dec_esc_xml</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with XML escape decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_dec_esc_url</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with URL escape decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_dec_esc_dquote</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string unescaping "" as "</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_dec_esc_squote</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string unescaping '' as '</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_erase</b>(<i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from string erasing portion from input</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t off</b>: byte offset</li><li><b>const size_t n</b>: number of bytes</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_erase_u</b>(<i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from Unicode "wide char" string erasing portion from input</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t char_off</b>: character offset</li><li><b>const size_t n</b>: number of characters</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_replace</b>(<i>const ss_t *src</i>, <i>const size_t off</i>, <i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Duplicate and apply replace operation after offset</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t off</b>:  offset (bytes)</li><li><b>const ss_t *s1</b>:  needle</li><li><b>const ss_t *s2</b>:  needle replacement</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_resize</b>(<i>const ss_t *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Duplicate and resize (byte addressing)</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t n</b>:  new size (bytes)</li><li><b>char fill_byte</b>:  fill byte</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_resize_u</b>(<i>ss_t *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Duplicate and resize (Unicode addressing)</li><li><b>ss_t *src</b>: string</li><li><b>const size_t n</b>:  new size (characters)</li><li><b>int fill_char</b>:  fill character</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_trim</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate and trim string</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_ltrim</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate and apply trim at left side</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_rtrim</b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate and apply trim at right side</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_printf</b>(<i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Duplicate from printf formatting</li><li><b>const size_t size</b>: printf space (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  optional printf parameters</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_printf_va</b>(<i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Duplicate from printf_va formatting</li><li><b>const size_t size</b>: printf_va space (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  variable argument reference</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_char</b>(<i>const int c</i>)<br><br><ul><li>Duplicate string from character</li><li><b>const int c</b>: Unicode character</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_dup_read</b>(<i>const int handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Duplicate from reading from file handle</li><li><b>const int handle</b>: file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with a string copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_sub</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Overwrite string with a substring copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const sv_t *offsets</b>:  separator offsets</li><li><b>const size_t nth</b>:  Nth substring to be used</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_substr</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with a substring copy (byte mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  input string start offset (bytes)</li><li><b>const size_t n</b>:  number of bytes to be copied</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_substr_u</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with a substring copy (character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t char_off</b>:  input string start offset (characters)</li><li><b>const size_t n</b>:  number of characters to be copied</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_cn</b>(<i>ss_t **s</i>, <i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Overwrite string with C string copy (strict aliasing is assumed)</li><li><b>ss_t **s</b>: output string</li><li><b>const char *src</b>:  input string</li><li><b>const size_t src_size</b>:  input string bytes</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_c</b>(<i>ss_t **s</i>, <i>...</i>)<br><br><ul><li>Overwrite string with multiple C string copy (strict aliasing is assumed)</li><li><b>ss_t **s</b>: output string</li><li><b>...</b>:  input strings (one or more C strings)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_wn</b>(<i>ss_t **s</i>, <i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Overwrite string with "wide char" Unicode string copy (strict aliasing is assumed)</li><li><b>ss_t **s</b>: output string</li><li><b>const wchar_t *src</b>:  input string ("wide char" Unicode)</li><li><b>const size_t src_size</b>:  input string number of characters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_int</b>(<i>ss_t **s</i>, <i>const sint_t num</i>)<br><br><ul><li>Overwrite string with integer to string copy</li><li><b>ss_t **s</b>: output string</li><li><b>const sint_t num</b>:  integer (any signed integer size)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_tolower</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string lowercase conversion copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_toupper</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string uppercase conversion copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_enc_b64</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string base64 encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_enc_hex</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (lowercase) encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_enc_HEX</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (uppercase) encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_enc_esc_json</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string JSON escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_enc_esc_xml</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string XML escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_enc_esc_url</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string URL escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_enc_esc_dquote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string escaping " as ""</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_enc_esc_squote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string escaping ' as ''</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_dec_b64</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string base64 decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_dec_hex</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (lowercase) decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_dec_esc_json</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string JSON escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_dec_esc_xml</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string XML escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_dec_esc_url</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string URL escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_dec_esc_dquote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string unescaping "" as "</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_dec_esc_squote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string unescaping '' as '</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_erase</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with input string copy applying a erase operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  input string erase start byte offset</li><li><b>const size_t n</b>:  number of bytes to erase</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_erase_u</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with input string copy applying a erase operation (character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t char_off</b>:  input string erase start character offset</li><li><b>const size_t n</b>:  number of characters to erase</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_replace</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Overwrite string with input string plus replace operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  offset for starting the replace operation (0 for the whole input string)</li><li><b>const ss_t *s1</b>:  pattern to be replaced</li><li><b>const ss_t *s2</b>:  patter replacement</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_resize</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Overwrite string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>char fill_byte</b>:  byte for refill</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_resize_u</b>(<i>ss_t **s</i>, <i>ss_t *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Overwrite string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>ss_t *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>int fill_char</b>:  byte for refill</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_trim</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string plus trim (left and right) space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_ltrim</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string plus left-trim space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_rtrim</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string plus right-trim space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_w</b>(<i>ss_t **s</i>, <i>...</i>)<br><br><ul><li>Overwrite string with multiple C "wide char" Unicode string copy (strict aliasing is assumed)</li><li><b>ss_t **s</b>: output string</li><li><b>...</b>:  input strings (one or more C "wide char" strings)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_printf</b>(<i>ss_t **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Overwrite string with printf operation</li><li><b>ss_t **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  printf parameters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_printf_va</b>(<i>ss_t **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Overwrite string with printf_va operation</li><li><b>ss_t **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  printf_va parameters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_char</b>(<i>ss_t **s</i>, <i>const int c</i>)<br><br><ul><li>Overwrite string with a string with just one character</li><li><b>ss_t **s</b>: output string</li><li><b>const int c</b>:  input character</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cpy_read</b>(<i>ss_t **s</i>, <i>const int handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Read from file handle</li><li><b>ss_t **s</b>: output string</li><li><b>const int handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_cat</b>(<i>ss_t **s</i>, <i>const ss_t *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate to string one or more strings</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *s1</b>:  input string</li><li><b>...</b>:  optional input strings</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_sub</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Concatenate substring token</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const sv_t *offsets</b>:  substring offsets</li><li><b>const size_t nth</b>: select nth substring</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_substr</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate substring (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  input string substring byte offset</li><li><b>const size_t n</b>:  input string substring size (bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_substr_u</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate substring (Unicode character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t char_off</b>:  input substring character offset</li><li><b>const size_t n</b>:  input string substring size (characters)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_cn</b>(<i>ss_t **s</i>, <i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Concatenate C substring (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const char *src</b>:  input C string</li><li><b>const size_t src_size</b>:  input string size (bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_c</b>(<i>ss_t **s</i>, <i>const char *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate multiple C strings (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const char *s1</b>:  input string</li><li><b>...</b>:  optional input strings</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_w</b>(<i>ss_t **s</i>, <i>const char *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate multiple "wide char" C strings (Unicode character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const char *s1</b>:  input "wide char" C string</li><li><b>...</b>:  optional input "wide char" C strings</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_wn</b>(<i>ss_t **s</i>, <i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Concatenate "wide char" C substring (Unicode character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const wchar_t *src</b>:  input "wide char" C string</li><li><b>const size_t src_size</b>:  input string size (characters)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_int</b>(<i>ss_t **s</i>, <i>const sint_t num</i>)<br><br><ul><li>Concatenate integer</li><li><b>ss_t **s</b>: output string</li><li><b>const sint_t num</b>:  integer (any signed integer size)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_tolower</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate "lowercased" string</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_toupper</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate "uppercased" string</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_enc_b64</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string base64 encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_enc_hex</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (lowercase) encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_enc_HEX</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (uppercase) encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_enc_esc_json</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string JSON escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_enc_esc_xml</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string XML escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_enc_esc_url</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string URL escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_enc_esc_dquote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string escaping " as ""</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_enc_esc_squote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string escaping ' as ''</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_dec_b64</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string base64 decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_dec_hex</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (lowercase) decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_dec_esc_json</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string JSON escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_dec_esc_xml</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string XML escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_dec_esc_url</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string URL escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_dec_esc_dquote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string unescaping "" as "</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_dec_esc_squote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string unescaping '' as '</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_erase</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate string with erase operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  input string byte offset for erase start</li><li><b>const size_t n</b>:  erase count (bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_erase_u</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate string with erase operation (Unicode character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t char_off</b>:  input character string offset for erase start</li><li><b>const size_t n</b>:  erase count (characters)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_replace</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Concatenate string with replace operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  offset for starting the replace operation (0 for the whole input string)</li><li><b>const ss_t *s1</b>:  pattern to be replaced</li><li><b>const ss_t *s2</b>:  patter replacement</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_resize</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Concatenate string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>char fill_byte</b>:  byte for refill</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_resize_u</b>(<i>ss_t **s</i>, <i>ss_t *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Concatenate string with input string copy plus resize operation (Unicode character)</li><li><b>ss_t **s</b>: output string</li><li><b>ss_t *src</b>:  input string</li><li><b>const size_t n</b>:  number of characters of input string</li><li><b>int fill_char</b>:  character for refill</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_trim</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string plus trim (left and right) space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_ltrim</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string plus left-trim space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_rtrim</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string plus right-trim space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_printf</b>(<i>ss_t **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Concatenate string with printf operation</li><li><b>ss_t **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  printf parameters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_printf_va</b>(<i>ss_t **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Concatenate string with printf_va operation</li><li><b>ss_t **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  printf_va parameters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_char</b>(<i>ss_t **s</i>, <i>const int c</i>)<br><br><ul><li>Concatenate string with a string with just one character</li><li><b>ss_t **s</b>: output string</li><li><b>const int c</b>:  input character</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_cat_read</b>(<i>ss_t **s</i>, <i>const int handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Cat data read from file handle</li><li><b>ss_t **s</b>: output string</li><li><b>const int handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_tolower</b>(<i>ss_t **s</i>)<br><br><ul><li>Convert string to lowercase</li><li><b>ss_t **s</b>: output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_toupper</b>(<i>ss_t **s</i>)<br><br><ul><li>Convert string to uppercase</li><li><b>ss_t **s</b>: output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_enc_b64</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert to base64</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_enc_hex</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert to hexadecimal (lowercase)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_enc_HEX</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert to hexadecimal (uppercase)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_enc_esc_json</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape for JSON encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_enc_esc_xml</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape for XML encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_enc_esc_url</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape for URL encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_enc_esc_dquote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape escaping " as ""</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_enc_esc_squote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape escaping ' as ''</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_dec_b64</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Decode from base64</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_dec_hex</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Decode from hexadecimal (lowercase)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_dec_esc_json</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape from JSON encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_dec_esc_xml</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape from XML encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_dec_esc_url</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape from URL encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_dec_esc_dquote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape "" as "</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_dec_esc_squote</b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape '' as '</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>ss_set_turkish_mode</b>(<i>const sbool_t enable_turkish_mode</i>)<br><br><ul><li>Set Turkish mode locale (related to case conversion)</li><li><b>const sbool_t enable_turkish_mode</b>: S_TRUE: enable turkish mode, S_FALSE: disable</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: conversion functions OK, S_FALSE: error (missing functions)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ss_t *</i><b>ss_clear</b>(<i>ss_t **s</i>)<br><br><ul><li>Clear string</li><li><b>ss_t **s</b>: output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_check</b>(<i>ss_t **s</i>)<br><br><ul><li>Check and fix string (if input string is NULL, replaces it with a empty valid string)</li><li><b>ss_t **s</b>: output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_erase</b>(<i>ss_t **s</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Erase portion of a string (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t off</b>:  byte offset where to start the cut</li><li><b>const size_t n</b>:  number of bytes to be cut</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_erase_u</b>(<i>ss_t **s</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Erase portion of a string (Unicode character mode)</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t char_off</b>:  character offset where to start the cut</li><li><b>const size_t n</b>:  number of characters to be cut</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_replace</b>(<i>ss_t **s</i>, <i>const size_t off</i>, <i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Replace into string</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t off</b>:  byte offset where to start applying the replace operation</li><li><b>const ss_t *s1</b>:  target pattern</li><li><b>const ss_t *s2</b>:  replacement pattern</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_resize</b>(<i>ss_t **s</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Resize string (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t n</b>:  new size in bytes</li><li><b>char fill_byte</b>:  fill byte</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_resize_u</b>(<i>ss_t **s</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Resize string (Unicode character mode)</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t n</b>:  new size in characters</li><li><b>int fill_char</b>:  fill character</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_trim</b>(<i>ss_t **s</i>)<br><br><ul><li>Remove spaces from left and right side</li><li><b>ss_t **s</b>: input/output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_ltrim</b>(<i>ss_t **s</i>)<br><br><ul><li>Remove spaces from left side</li><li><b>ss_t **s</b>: input/output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b>ss_rtrim</b>(<i>ss_t **s</i>)<br><br><ul><li>Remove spaces from right side</li><li><b>ss_t **s</b>: input/output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const char *</i><b>ss_to_c</b>(<i>ss_t *s</i>)<br><br><ul><li>Give a C-compatible zero-ended string reference (byte/UTF-8 mode)</li><li><b>ss_t *s</b>: input string</li><li><b>Return</b> (<i>const char *</i>): Zero-ended C compatible string reference (UTF-8)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const wchar_t *</i><b>ss_to_w</b>(<i>const ss_t *s</i>, <i>wchar_t *o</i>, <i>const size_t nmax</i>, <i>size_t *n</i>)<br><br><ul><li>Give a C-compatible zero-ended string reference ("wide char" Unicode mode)</li><li><b>const ss_t *s</b>: input string</li><li><b>wchar_t *o</b>:  output string buffer</li><li><b>const size_t nmax</b>:  output string max characters</li><li><b>size_t *n</b>:  output string size</li><li><b>Return</b> (<i>const wchar_t *</i>): Zero'ended C compatible string reference ("wide char" Unicode mode)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_find</b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const ss_t *tgt</i>)<br><br><ul><li>Find substring into string</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const ss_t *tgt</b>:  target string</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_split</b>(<i>sv_t **offsets</i>, <i>const ss_t *src</i>, <i>const ss_t *separator</i>)<br><br><ul><li>Split/tokenize: break string by separators</li><li><b>sv_t **offsets</b>: output offset structure</li><li><b>const ss_t *src</b>: input string</li><li><b>const ss_t *separator</b>:  separator</li><li><b>Return</b> (<i>size_t</i>): Number of elements</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_nth_size</b>(<i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Substring size</li><li><b>const sv_t *offsets</b>: substring offset data</li><li><b>const size_t nth</b>:  n-th element</li><li><b>Return</b> (<i>size_t</i>): Size in bytes of the n-th element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>ss_nth_offset</b>(<i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Substring offset</li><li><b>const sv_t *offsets</b>: substring offset data</li><li><b>const size_t nth</b>:  n-th element</li><li><b>Return</b> (<i>size_t</i>): Offset in bytes of the n-th element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>ss_cmp</b>(<i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>String compare</li><li><b>const ss_t *s1</b>: string 1</li><li><b>const ss_t *s2</b>:  string 2</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>ss_cmpi</b>(<i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Case-insensitive string compare</li><li><b>const ss_t *s1</b>: string 1</li><li><b>const ss_t *s2</b>:  string 2</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>ss_ncmp</b>(<i>const ss_t *s1</i>, <i>const size_t s1off</i>, <i>const ss_t *s2</i>, <i>const size_t n</i>)<br><br><ul><li>Partial string compare</li><li><b>const ss_t *s1</b>: string 1</li><li><b>const size_t s1off</b>:  string 1 offset (bytes</li><li><b>const ss_t *s2</b>:  string 2</li><li><b>const size_t n</b>:  comparison size (bytes)</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>ss_ncmpi</b>(<i>const ss_t *s1</i>, <i>const size_t s1off</i>, <i>const ss_t *s2</i>, <i>const size_t n</i>)<br><br><ul><li>Partial case insensitive string compare</li><li><b>const ss_t *s1</b>: string 1</li><li><b>const size_t s1off</b>:  string 1 offset (bytes</li><li><b>const ss_t *s2</b>:  string 2</li><li><b>const size_t n</b>:  comparison size (bytes)</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>ss_printf</b>(<i>ss_t **s</i>, <i>size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>printf operation on string</li><li><b>ss_t **s</b>: output string</li><li><b>size_t size</b>:  printf max output size -including the 0 terminator- (bytes)</li><li><b>const char *fmt</b>:  printf "format"</li><li><b>...</b>: printf "format" parameters</li><li><b>Return</b> (<i>int</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>ss_getchar</b>(<i>const ss_t *s</i>, <i>size_t *autoinc_off</i>)<br><br><ul><li>Get next Unicode character</li><li><b>const ss_t *s</b>: input string</li><li><b>size_t *autoinc_off</b>:  iterator</li><li><b>Return</b> (<i>int</i>): Output character, or EOF if no more characters left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>ss_putchar</b>(<i>ss_t **s</i>, <i>const int c</i>)<br><br><ul><li>Append Unicode character to string</li><li><b>ss_t **s</b>: output string</li><li><b>const int c</b>:  Unicode character</li><li><b>Return</b> (<i>int</i>): Echo of the output character or EOF if overflow error</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>ss_popchar</b>(<i>ss_t **s</i>)<br><br><ul><li>Extract last character from string</li><li><b>ss_t **s</b>: input/output string</li><li><b>Return</b> (<i>int</i>): Extracted character if OK, EOF if empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b>ss_read</b>(<i>ss_t **s</i>, <i>const int handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Read from file handle</li><li><b>ss_t **s</b>: output string</li><li><b>const int handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ssize_t</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>unsigned </i><b>ss_csum32</b>(<i>const ss_t *s</i>, <i>const size_t n</i>)<br><br><ul><li>Simple hash: 32-bit checksum</li><li><b>const ss_t *s</b>: string</li><li><b>const size_t n</b>:  0: compare all string, 1 <= n < N compare first N elements</li><li><b>Return</b> (<i>unsigned</i>): 32-bit hash</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
</body></html>

