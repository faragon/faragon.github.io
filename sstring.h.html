<!doctype html><html><body><h3>Documentation for sstring.h</h3><br><table><tr><th align="left">&nbsp;<a href="#ss_alloc">ss_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_replace">ss_cat_replace</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_squote">ss_cpy_enc_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_c">ss_dup_c</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_tolower">ss_dup_tolower</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_get_buffer_size">ss_get_buffer_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_alloc_errors">ss_alloc_errors</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_resize">ss_cat_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_url">ss_cpy_enc_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_char">ss_dup_char</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_toupper">ss_dup_toupper</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_getchar">ss_getchar</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_alloca">ss_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_resize_u">ss_cat_resize_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_xml">ss_cpy_enc_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_cn">ss_dup_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_trim">ss_dup_trim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_grow">ss_grow</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_at">ss_at</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_rtrim">ss_cat_rtrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_hex">ss_cpy_enc_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_b64">ss_dup_dec_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_w">ss_dup_w</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_len">ss_len</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_capacity">ss_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_sub">ss_cat_sub</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_erase">ss_cpy_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_dquote">ss_dup_dec_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_wn">ss_dup_wn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_len_u">ss_len_u</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_capacity_left">ss_capacity_left</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_substr">ss_cat_substr</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_erase_u">ss_cpy_erase_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_json">ss_dup_dec_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_empty">ss_empty</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_ltrim">ss_ltrim</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat">ss_cat</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_substr_u">ss_cat_substr_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_int">ss_cpy_int</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_squote">ss_dup_dec_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_HEX">ss_enc_HEX</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_max">ss_max</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_c">ss_cat_c</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_tolower">ss_cat_tolower</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_ltrim">ss_cpy_ltrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_url">ss_dup_dec_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_b64">ss_enc_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_ncmp">ss_ncmp</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_char">ss_cat_char</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_toupper">ss_cat_toupper</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_printf">ss_cpy_printf</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_xml">ss_dup_dec_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_dquote">ss_enc_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_ncmpi">ss_ncmpi</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_cn">ss_cat_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_trim">ss_cat_trim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_printf_va">ss_cpy_printf_va</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_hex">ss_dup_dec_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_json">ss_enc_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_nth_offset">ss_nth_offset</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_b64">ss_cat_dec_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_w">ss_cat_w</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_read">ss_cpy_read</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_HEX">ss_dup_enc_HEX</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_squote">ss_enc_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_nth_size">ss_nth_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_dquote">ss_cat_dec_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_wn">ss_cat_wn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_replace">ss_cpy_replace</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_b64">ss_dup_enc_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_url">ss_enc_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_popchar">ss_popchar</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_json">ss_cat_dec_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_check">ss_check</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_resize">ss_cpy_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_dquote">ss_dup_enc_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_xml">ss_enc_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_printf">ss_printf</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_squote">ss_cat_dec_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_clear">ss_clear</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_resize_u">ss_cpy_resize_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_json">ss_dup_enc_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_hex">ss_enc_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_putchar">ss_putchar</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_url">ss_cat_dec_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_clear_errors">ss_clear_errors</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_rtrim">ss_cpy_rtrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_squote">ss_dup_enc_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_encoding_errors">ss_encoding_errors</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_read">ss_read</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_xml">ss_cat_dec_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cmp">ss_cmp</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_sub">ss_cpy_sub</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_url">ss_dup_enc_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_erase">ss_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_real_off">ss_real_off</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_hex">ss_cat_dec_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cmpi">ss_cmpi</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_substr">ss_cpy_substr</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_xml">ss_dup_enc_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_erase_u">ss_erase_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_replace">ss_replace</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_HEX">ss_cat_enc_HEX</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy">ss_cpy</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_substr_u">ss_cpy_substr_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_hex">ss_dup_enc_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_find">ss_find</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_reserve">ss_reserve</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_b64">ss_cat_enc_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_c">ss_cpy_c</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_tolower">ss_cpy_tolower</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_erase">ss_dup_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_find_cn">ss_find_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_resize">ss_resize</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_dquote">ss_cat_enc_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_char">ss_cpy_char</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_toupper">ss_cpy_toupper</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_erase_u">ss_dup_erase_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findb">ss_findb</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_resize_u">ss_resize_u</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_json">ss_cat_enc_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_cn">ss_cpy_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_trim">ss_cpy_trim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_int">ss_dup_int</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findbm">ss_findbm</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_rtrim">ss_rtrim</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_squote">ss_cat_enc_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_b64">ss_cpy_dec_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_w">ss_cpy_w</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_ltrim">ss_dup_ltrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findc">ss_findc</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_set_size">ss_set_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_url">ss_cat_enc_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_dquote">ss_cpy_dec_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_wn">ss_cpy_wn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_printf">ss_dup_printf</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findnb">ss_findnb</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_set_turkish_mode">ss_set_turkish_mode</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_xml">ss_cat_enc_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_json">ss_cpy_dec_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_csum32">ss_csum32</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_printf_va">ss_dup_printf_va</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findr">ss_findr</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_shrink">ss_shrink</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_hex">ss_cat_enc_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_squote">ss_cpy_dec_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_b64">ss_dec_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_read">ss_dup_read</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findr_cn">ss_findr_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_size">ss_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_erase">ss_cat_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_url">ss_cpy_dec_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_dquote">ss_dec_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_replace">ss_dup_replace</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findrb">ss_findrb</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_split">ss_split</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_erase_u">ss_cat_erase_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_xml">ss_cpy_dec_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_json">ss_dec_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_resize">ss_dup_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findrbm">ss_findrbm</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_to_c">ss_to_c</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_int">ss_cat_int</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_hex">ss_cpy_dec_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_squote">ss_dec_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_resize_u">ss_dup_resize_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findrc">ss_findrc</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_to_w">ss_to_w</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_ltrim">ss_cat_ltrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_HEX">ss_cpy_enc_HEX</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_url">ss_dec_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_rtrim">ss_dup_rtrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findrnb">ss_findrnb</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_tolower">ss_tolower</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_printf">ss_cat_printf</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_b64">ss_cpy_enc_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_xml">ss_dec_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_sub">ss_dup_sub</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_free">ss_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_toupper">ss_toupper</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_printf_va">ss_cat_printf_va</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_dquote">ss_cpy_enc_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_hex">ss_dec_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_substr">ss_dup_substr</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_get_buffer">ss_get_buffer</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_trim">ss_trim</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_read">ss_cat_read</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_json">ss_cpy_enc_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup">ss_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_substr_u">ss_dup_substr_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_get_buffer_r">ss_get_buffer_r</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_write">ss_write</a>&nbsp;</th></tr></table><br><br><i>ss_t *</i><b><a name="ss_alloc">ss_alloc</a></b>(<i>const size_t initial_heap_reserve</i>)<br><br><ul><li>Allocate string (heap)</li><li><b>const size_t initial_heap_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>ss_t *</i>): allocated string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="ss_alloc_errors">ss_alloc_errors</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Check if string had allocation errors</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: has errors; S_FALSE: no errors</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_alloca">ss_alloca</a></b>(<i>const size_t max_size</i>)<br><br><ul><li>Allocate string (stack)</li><li><b>const size_t max_size</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>ss_t *</i>): allocated string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_at">ss_at</a></b>(<i>const ss_t *s</i>, <i>size_t off</i>)<br><br><ul><li>Random access to byte</li><li><b>const ss_t *s</b>: string</li><li><b>size_t off</b>:  offset (bytes)</li><li><b>Return</b> (<i>int</i>): 0..255: byte retrieved ok; < 0: out of range</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_capacity">ss_capacity</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Get allocated space</li><li><b>const ss_t *s</b>: vector</li><li><b>Return</b> (<i>size_t</i>): current allocated space (in bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_capacity_left">ss_capacity_left</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Get preallocated space left</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): allocated space left (in bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat">ss_cat</a></b>(<i>ss_t **s</i>, <i>const ss_t *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate to string one or more strings</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *s1</b>:  input string</li><li><b>...</b>:  optional input strings</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_c">ss_cat_c</a></b>(<i>ss_t **s</i>, <i>const char *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate multiple C strings (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const char *s1</b>:  input string</li><li><b>...</b>:  optional input strings</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_char">ss_cat_char</a></b>(<i>ss_t **s</i>, <i>const int c</i>)<br><br><ul><li>Concatenate string with a string with just one character</li><li><b>ss_t **s</b>: output string</li><li><b>const int c</b>:  input character</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_cn">ss_cat_cn</a></b>(<i>ss_t **s</i>, <i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Concatenate C substring (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const char *src</b>:  input C string</li><li><b>const size_t src_size</b>:  input string size (bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_dec_b64">ss_cat_dec_b64</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string base64 decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_dec_esc_dquote">ss_cat_dec_esc_dquote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string unescaping "" as "</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_dec_esc_json">ss_cat_dec_esc_json</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string JSON escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_dec_esc_squote">ss_cat_dec_esc_squote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string unescaping '' as '</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_dec_esc_url">ss_cat_dec_esc_url</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string URL escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_dec_esc_xml">ss_cat_dec_esc_xml</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string XML escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_dec_hex">ss_cat_dec_hex</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (lowercase) decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_enc_HEX">ss_cat_enc_HEX</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (uppercase) encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_enc_b64">ss_cat_enc_b64</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string base64 encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_enc_esc_dquote">ss_cat_enc_esc_dquote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string escaping " as ""</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_enc_esc_json">ss_cat_enc_esc_json</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string JSON escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_enc_esc_squote">ss_cat_enc_esc_squote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string escaping ' as ''</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_enc_esc_url">ss_cat_enc_esc_url</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string URL escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_enc_esc_xml">ss_cat_enc_esc_xml</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string XML escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_enc_hex">ss_cat_enc_hex</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (lowercase) encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_erase">ss_cat_erase</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate string with erase operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  input string byte offset for erase start</li><li><b>const size_t n</b>:  erase count (bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_erase_u">ss_cat_erase_u</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate string with erase operation (Unicode character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t char_off</b>:  input character string offset for erase start</li><li><b>const size_t n</b>:  erase count (characters)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_int">ss_cat_int</a></b>(<i>ss_t **s</i>, <i>const int64_t num</i>)<br><br><ul><li>Concatenate integer</li><li><b>ss_t **s</b>: output string</li><li><b>const int64_t num</b>:  integer (any signed integer size)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_ltrim">ss_cat_ltrim</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string plus left-trim space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_printf">ss_cat_printf</a></b>(<i>ss_t **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Concatenate string with printf operation</li><li><b>ss_t **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  printf parameters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_printf_va">ss_cat_printf_va</a></b>(<i>ss_t **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Concatenate string with printf_va operation</li><li><b>ss_t **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  printf_va parameters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_read">ss_cat_read</a></b>(<i>ss_t **s</i>, <i>FILE *handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Cat data read from file handle</li><li><b>ss_t **s</b>: output string</li><li><b>FILE *handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_replace">ss_cat_replace</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Concatenate string with replace operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  offset for starting the replace operation (0 for the whole input string)</li><li><b>const ss_t *s1</b>:  pattern to be replaced</li><li><b>const ss_t *s2</b>:  patter replacement</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_resize">ss_cat_resize</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Concatenate string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>char fill_byte</b>:  byte for refill</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_resize_u">ss_cat_resize_u</a></b>(<i>ss_t **s</i>, <i>ss_t *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Concatenate string with input string copy plus resize operation (Unicode character)</li><li><b>ss_t **s</b>: output string</li><li><b>ss_t *src</b>:  input string</li><li><b>const size_t n</b>:  number of characters of input string</li><li><b>int fill_char</b>:  character for refill</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_rtrim">ss_cat_rtrim</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string plus right-trim space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_sub">ss_cat_sub</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Concatenate substring token</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const sv_t *offsets</b>:  substring offsets</li><li><b>const size_t nth</b>: select nth substring</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_substr">ss_cat_substr</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate substring (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  input string substring byte offset</li><li><b>const size_t n</b>:  input string substring size (bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_substr_u">ss_cat_substr_u</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate substring (Unicode character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t char_off</b>:  input substring character offset</li><li><b>const size_t n</b>:  input string substring size (characters)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_tolower">ss_cat_tolower</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate "lowercased" string</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_toupper">ss_cat_toupper</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate "uppercased" string</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_trim">ss_cat_trim</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Concatenate string with input string plus trim (left and right) space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_w">ss_cat_w</a></b>(<i>ss_t **s</i>, <i>const char *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate multiple "wide char" C strings (Unicode character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const char *s1</b>:  input "wide char" C string</li><li><b>...</b>:  optional input "wide char" C strings</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cat_wn">ss_cat_wn</a></b>(<i>ss_t **s</i>, <i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Concatenate "wide char" C substring (Unicode character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const wchar_t *src</b>:  input "wide char" C string</li><li><b>const size_t src_size</b>:  input string size (characters)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_check">ss_check</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Check and fix string (if input string is NULL, replaces it with a empty valid string)</li><li><b>ss_t **s</b>: output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_clear">ss_clear</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Clear string</li><li><b>ss_t **s</b>: output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="ss_clear_errors">ss_clear_errors</a></b>(<i>ss_t *s</i>)<br><br><ul><li>Clear allocation/encoding error flags</li><li><b>ss_t *s</b>: string</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_cmp">ss_cmp</a></b>(<i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>String compare</li><li><b>const ss_t *s1</b>: string 1</li><li><b>const ss_t *s2</b>:  string 2</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_cmpi">ss_cmpi</a></b>(<i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Case-insensitive string compare</li><li><b>const ss_t *s1</b>: string 1</li><li><b>const ss_t *s2</b>:  string 2</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy">ss_cpy</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with a string copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_c">ss_cpy_c</a></b>(<i>ss_t **s</i>, <i>...</i>)<br><br><ul><li>Overwrite string with multiple C string copy (strict aliasing is assumed)</li><li><b>ss_t **s</b>: output string</li><li><b>...</b>:  input strings (one or more C strings)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_char">ss_cpy_char</a></b>(<i>ss_t **s</i>, <i>const int c</i>)<br><br><ul><li>Overwrite string with a string with just one character</li><li><b>ss_t **s</b>: output string</li><li><b>const int c</b>:  input character</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_cn">ss_cpy_cn</a></b>(<i>ss_t **s</i>, <i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Overwrite string with C string copy (strict aliasing is assumed)</li><li><b>ss_t **s</b>: output string</li><li><b>const char *src</b>:  input string</li><li><b>const size_t src_size</b>:  input string bytes</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_dec_b64">ss_cpy_dec_b64</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string base64 decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_dec_esc_dquote">ss_cpy_dec_esc_dquote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string unescaping "" as "</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_dec_esc_json">ss_cpy_dec_esc_json</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string JSON escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_dec_esc_squote">ss_cpy_dec_esc_squote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string unescaping '' as '</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_dec_esc_url">ss_cpy_dec_esc_url</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string URL escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_dec_esc_xml">ss_cpy_dec_esc_xml</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string XML escape decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_dec_hex">ss_cpy_dec_hex</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (lowercase) decoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_enc_HEX">ss_cpy_enc_HEX</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (uppercase) encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_enc_b64">ss_cpy_enc_b64</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string base64 encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_enc_esc_dquote">ss_cpy_enc_esc_dquote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string escaping " as ""</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_enc_esc_json">ss_cpy_enc_esc_json</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string JSON escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_enc_esc_squote">ss_cpy_enc_esc_squote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string escaping ' as ''</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_enc_esc_url">ss_cpy_enc_esc_url</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string URL escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_enc_esc_xml">ss_cpy_enc_esc_xml</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string XML escape encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_enc_hex">ss_cpy_enc_hex</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (lowercase) encoding copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_erase">ss_cpy_erase</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with input string copy applying a erase operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  input string erase start byte offset</li><li><b>const size_t n</b>:  number of bytes to erase</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_erase_u">ss_cpy_erase_u</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with input string copy applying a erase operation (character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t char_off</b>:  input string erase start character offset</li><li><b>const size_t n</b>:  number of characters to erase</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_int">ss_cpy_int</a></b>(<i>ss_t **s</i>, <i>const int64_t num</i>)<br><br><ul><li>Overwrite string with integer to string copy</li><li><b>ss_t **s</b>: output string</li><li><b>const int64_t num</b>:  integer (any signed integer size)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_ltrim">ss_cpy_ltrim</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string plus left-trim space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_printf">ss_cpy_printf</a></b>(<i>ss_t **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Overwrite string with printf operation</li><li><b>ss_t **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  printf parameters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_printf_va">ss_cpy_printf_va</a></b>(<i>ss_t **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Overwrite string with printf_va operation</li><li><b>ss_t **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  printf_va parameters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_read">ss_cpy_read</a></b>(<i>ss_t **s</i>, <i>FILE *handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Read from file handle</li><li><b>ss_t **s</b>: output string</li><li><b>FILE *handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_replace">ss_cpy_replace</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Overwrite string with input string plus replace operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  offset for starting the replace operation (0 for the whole input string)</li><li><b>const ss_t *s1</b>:  pattern to be replaced</li><li><b>const ss_t *s2</b>:  patter replacement</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_resize">ss_cpy_resize</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Overwrite string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>char fill_byte</b>:  byte for refill</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_resize_u">ss_cpy_resize_u</a></b>(<i>ss_t **s</i>, <i>ss_t *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Overwrite string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: output string</li><li><b>ss_t *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>int fill_char</b>:  byte for refill</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_rtrim">ss_cpy_rtrim</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string plus right-trim space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_sub">ss_cpy_sub</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Overwrite string with a substring copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const sv_t *offsets</b>:  separator offsets</li><li><b>const size_t nth</b>:  Nth substring to be used</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_substr">ss_cpy_substr</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with a substring copy (byte mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t off</b>:  input string start offset (bytes)</li><li><b>const size_t n</b>:  number of bytes to be copied</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_substr_u">ss_cpy_substr_u</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with a substring copy (character mode)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>const size_t char_off</b>:  input string start offset (characters)</li><li><b>const size_t n</b>:  number of characters to be copied</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_tolower">ss_cpy_tolower</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string lowercase conversion copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_toupper">ss_cpy_toupper</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string uppercase conversion copy</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_trim">ss_cpy_trim</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Overwrite string with input string plus trim (left and right) space removal operation</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_w">ss_cpy_w</a></b>(<i>ss_t **s</i>, <i>...</i>)<br><br><ul><li>Overwrite string with multiple C "wide char" Unicode string copy (strict aliasing is assumed)</li><li><b>ss_t **s</b>: output string</li><li><b>...</b>:  input strings (one or more C "wide char" strings)</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_cpy_wn">ss_cpy_wn</a></b>(<i>ss_t **s</i>, <i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Overwrite string with "wide char" Unicode string copy (strict aliasing is assumed)</li><li><b>ss_t **s</b>: output string</li><li><b>const wchar_t *src</b>:  input string ("wide char" Unicode)</li><li><b>const size_t src_size</b>:  input string number of characters</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>unsigned </i><b><a name="ss_csum32">ss_csum32</a></b>(<i>const ss_t *s</i>, <i>const size_t n</i>)<br><br><ul><li>Simple hash: 32-bit checksum</li><li><b>const ss_t *s</b>: string</li><li><b>const size_t n</b>:  0: compare all string, 1 <= n < N compare first N elements</li><li><b>Return</b> (<i>unsigned</i>): 32-bit hash</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dec_b64">ss_dec_b64</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Decode from base64</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dec_esc_dquote">ss_dec_esc_dquote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape "" as "</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dec_esc_json">ss_dec_esc_json</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape from JSON encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dec_esc_squote">ss_dec_esc_squote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape '' as '</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dec_esc_url">ss_dec_esc_url</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape from URL encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dec_esc_xml">ss_dec_esc_xml</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Unescape from XML encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dec_hex">ss_dec_hex</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Decode from hexadecimal (lowercase)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup">ss_dup</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): Output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_c">ss_dup_c</a></b>(<i>const char *src</i>)<br><br><ul><li>Duplicate from C String (ASCII-z)</li><li><b>const char *src</b>: C string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_char">ss_dup_char</a></b>(<i>const int c</i>)<br><br><ul><li>Duplicate string from character</li><li><b>const int c</b>: Unicode character</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_cn">ss_dup_cn</a></b>(<i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Duplicate from C string</li><li><b>const char *src</b>: C string buffer</li><li><b>const size_t src_size</b>: number of bytes</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_dec_b64">ss_dup_dec_b64</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with base64 decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_dec_esc_dquote">ss_dup_dec_esc_dquote</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string unescaping "" as "</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_dec_esc_json">ss_dup_dec_esc_json</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with JSON escape decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_dec_esc_squote">ss_dup_dec_esc_squote</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string unescaping '' as '</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_dec_esc_url">ss_dup_dec_esc_url</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with URL escape decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_dec_esc_xml">ss_dup_dec_esc_xml</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with XML escape decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_dec_hex">ss_dup_dec_hex</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with hex decoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_enc_HEX">ss_dup_enc_HEX</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with hex encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_enc_b64">ss_dup_enc_b64</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with base64 encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_enc_esc_dquote">ss_dup_enc_esc_dquote</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string escaping " as ""</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_enc_esc_json">ss_dup_enc_esc_json</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with JSON escape encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_enc_esc_squote">ss_dup_enc_esc_squote</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string escaping ' as ''</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_enc_esc_url">ss_dup_enc_esc_url</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with URL escape encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_enc_esc_xml">ss_dup_enc_esc_xml</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with XML escape encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_enc_hex">ss_dup_enc_hex</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with hex encoding</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_erase">ss_dup_erase</a></b>(<i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from string erasing portion from input</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t off</b>: byte offset</li><li><b>const size_t n</b>: number of bytes</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_erase_u">ss_dup_erase_u</a></b>(<i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from Unicode "wide char" string erasing portion from input</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t char_off</b>: character offset</li><li><b>const size_t n</b>: number of characters</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_int">ss_dup_int</a></b>(<i>const int64_t num</i>)<br><br><ul><li>Duplicate from integer</li><li><b>const int64_t num</b>: integer</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_ltrim">ss_dup_ltrim</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate and apply trim at left side</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_printf">ss_dup_printf</a></b>(<i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Duplicate from printf formatting</li><li><b>const size_t size</b>: printf space (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  optional printf parameters</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_printf_va">ss_dup_printf_va</a></b>(<i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Duplicate from printf_va formatting</li><li><b>const size_t size</b>: printf_va space (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  variable argument reference</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_read">ss_dup_read</a></b>(<i>FILE *handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Duplicate from reading from file handle</li><li><b>FILE *handle</b>: file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_replace">ss_dup_replace</a></b>(<i>const ss_t *src</i>, <i>const size_t off</i>, <i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Duplicate and apply replace operation after offset</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t off</b>:  offset (bytes)</li><li><b>const ss_t *s1</b>:  needle</li><li><b>const ss_t *s2</b>:  needle replacement</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_resize">ss_dup_resize</a></b>(<i>const ss_t *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Duplicate and resize (byte addressing)</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t n</b>:  new size (bytes)</li><li><b>char fill_byte</b>:  fill byte</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_resize_u">ss_dup_resize_u</a></b>(<i>ss_t *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Duplicate and resize (Unicode addressing)</li><li><b>ss_t *src</b>: string</li><li><b>const size_t n</b>:  new size (characters)</li><li><b>int fill_char</b>:  fill character</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_rtrim">ss_dup_rtrim</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate and apply trim at right side</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_sub">ss_dup_sub</a></b>(<i>const ss_t *src</i>, <i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Duplicate from substring</li><li><b>const ss_t *src</b>: string</li><li><b>const sv_t *offsets</b>: substring offsets</li><li><b>const size_t nth</b>: select nth substring</li><li><b>Return</b> (<i>ss_t *</i>): Output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_substr">ss_dup_substr</a></b>(<i>const ss_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from substring</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t off</b>: byte offset</li><li><b>const size_t n</b>: number of bytes</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_substr_u">ss_dup_substr_u</a></b>(<i>const ss_t *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from substring</li><li><b>const ss_t *src</b>: string</li><li><b>const size_t char_off</b>: character offset</li><li><b>const size_t n</b>: number of characters</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_tolower">ss_dup_tolower</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with lowercase conversion</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_toupper">ss_dup_toupper</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate string with uppercase conversion</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_trim">ss_dup_trim</a></b>(<i>const ss_t *src</i>)<br><br><ul><li>Duplicate and trim string</li><li><b>const ss_t *src</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_w">ss_dup_w</a></b>(<i>const wchar_t *src</i>)<br><br><ul><li>Duplicate from "wide char" Unicode string</li><li><b>const wchar_t *src</b>: "wide char" string</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_dup_wn">ss_dup_wn</a></b>(<i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Duplicate from Unicode "wide char" string</li><li><b>const wchar_t *src</b>: "wide char" string</li><li><b>const size_t src_size</b>:  number of characters</li><li><b>Return</b> (<i>ss_t *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="ss_empty">ss_empty</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Tells if a string is empty (zero elements)</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: empty string; S_FALSE: not empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_enc_HEX">ss_enc_HEX</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert to hexadecimal (uppercase)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_enc_b64">ss_enc_b64</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert to base64</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_enc_esc_dquote">ss_enc_esc_dquote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape escaping " as ""</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_enc_esc_json">ss_enc_esc_json</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape for JSON encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_enc_esc_squote">ss_enc_esc_squote</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape escaping ' as ''</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_enc_esc_url">ss_enc_esc_url</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape for URL encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_enc_esc_xml">ss_enc_esc_xml</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert/escape for XML encoding</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_enc_hex">ss_enc_hex</a></b>(<i>ss_t **s</i>, <i>const ss_t *src</i>)<br><br><ul><li>Convert to hexadecimal (lowercase)</li><li><b>ss_t **s</b>: output string</li><li><b>const ss_t *src</b>:  input string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="ss_encoding_errors">ss_encoding_errors</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Check if string had UTF8 encoding errors</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: has errors; S_FALSE: no errors</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_erase">ss_erase</a></b>(<i>ss_t **s</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Erase portion of a string (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t off</b>:  byte offset where to start the cut</li><li><b>const size_t n</b>:  number of bytes to be cut</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_erase_u">ss_erase_u</a></b>(<i>ss_t **s</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Erase portion of a string (Unicode character mode)</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t char_off</b>:  character offset where to start the cut</li><li><b>const size_t n</b>:  number of characters to be cut</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_find">ss_find</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const ss_t *tgt</i>)<br><br><ul><li>Find substring into string</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const ss_t *tgt</b>:  target string</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_find_cn">ss_find_cn</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const char *t</i>, <i>const size_t ts</i>)<br><br><ul><li>Find n bytes</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const char *t</b>:  target buffer</li><li><b>const size_t ts</b>:  target buffer size (bytes)</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findb">ss_findb</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>)<br><br><ul><li>Find blank (9, 10, 13, 32) character into string</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findbm">ss_findbm</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>unsigned char incl_mask</i>, <i>const unsigned char excl_mask</i>)<br><br><ul><li>Find byte(s) via mask into string</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>unsigned char incl_mask</b>:  target byte include mask</li><li><b>const unsigned char excl_mask</b>:  target byte exclude mask</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findc">ss_findc</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const int c</i>)<br><br><ul><li>Find character into string</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const int c</b>:  target character</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findnb">ss_findnb</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>)<br><br><ul><li>Find non-blank (9, 10, 13, 32) character into string</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findr">ss_findr</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const ss_t *tgt</i>)<br><br><ul><li>Find substring into string (in range)</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const ss_t *tgt</b>:  target string</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findr_cn">ss_findr_cn</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const char *t</i>, <i>const size_t ts</i>)<br><br><ul><li>Find n bytes</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const char *t</b>:  target buffer</li><li><b>const size_t ts</b>:  target buffer size (bytes)</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findrb">ss_findrb</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>)<br><br><ul><li>Find blank (9, 10, 13, 32) character into string (in range)</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findrbm">ss_findrbm</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const unsigned char incl_mask</i>, <i>const unsigned char excl_mask</i>)<br><br><ul><li>Find byte(s) via mask into string (in range)</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const unsigned char incl_mask</b>:  target byte include mask</li><li><b>const unsigned char excl_mask</b>:  target byte exclude mask</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findrc">ss_findrc</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const int c</i>)<br><br><ul><li>Find character into string (in range)</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const int c</b>:  target character</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findrnb">ss_findrnb</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>)<br><br><ul><li>Find non-blank (9, 10, 13, 32) character into string (in range)</li><li><b>const ss_t *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="ss_free">ss_free</a></b>(<i>ss_t **s</i>, <i>...</i>)<br><br><ul><li>Free one or more strings (heap)</li><li><b>ss_t **s</b>: string</li><li><b>...</b>: more strings (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>char *</i><b><a name="ss_get_buffer">ss_get_buffer</a></b>(<i>ss_t *s</i>)<br><br><ul><li>Get string buffer access</li><li><b>ss_t *s</b>: string</li><li><b>Return</b> (<i>char *</i>): pointer to the insternal string buffer (UTF-8 or raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const char *</i><b><a name="ss_get_buffer_r">ss_get_buffer_r</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Get string buffer access (read-only)</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>const char *</i>): pointer to the internal string buffer (UTF-8 or raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_get_buffer_size">ss_get_buffer_size</a></b>(<i>const ss_t *v</i>)<br><br><ul><li>Get string buffer size</li><li><b>const ss_t *v</b>: string</li><li><b>Return</b> (<i>size_t</i>): Number of bytes in use for storing all string characters</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_getchar">ss_getchar</a></b>(<i>const ss_t *s</i>, <i>size_t *autoinc_off</i>)<br><br><ul><li>Get next Unicode character</li><li><b>const ss_t *s</b>: input string</li><li><b>size_t *autoinc_off</b>:  iterator</li><li><b>Return</b> (<i>int</i>): Output character, or EOF if no more characters left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_grow">ss_grow</a></b>(<i>ss_t **s</i>, <i>const size_t extra_elems</i>)<br><br><ul><li>Reserve space for extra elements (relative to current string size)</li><li><b>ss_t **s</b>: string</li><li><b>const size_t extra_elems</b>: number of extra elements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_len">ss_len</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Equivalent to ss_size</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): Number of bytes (UTF-8 string length)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_len_u">ss_len_u</a></b>(<i>ss_t *s</i>)<br><br><ul><li>String length (Unicode)</li><li><b>ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): number of Unicode characters</li><li><b>Time complexity:</b> O(1) if cached, O(n) if not previously computed</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_ltrim">ss_ltrim</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Remove spaces from left side</li><li><b>ss_t **s</b>: input/output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_max">ss_max</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Get the maximum possible string size</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): max string size (bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_ncmp">ss_ncmp</a></b>(<i>const ss_t *s1</i>, <i>const size_t s1off</i>, <i>const ss_t *s2</i>, <i>const size_t n</i>)<br><br><ul><li>Partial string compare</li><li><b>const ss_t *s1</b>: string 1</li><li><b>const size_t s1off</b>:  string 1 offset (bytes</li><li><b>const ss_t *s2</b>:  string 2</li><li><b>const size_t n</b>:  comparison size (bytes)</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_ncmpi">ss_ncmpi</a></b>(<i>const ss_t *s1</i>, <i>const size_t s1off</i>, <i>const ss_t *s2</i>, <i>const size_t n</i>)<br><br><ul><li>Partial case insensitive string compare</li><li><b>const ss_t *s1</b>: string 1</li><li><b>const size_t s1off</b>:  string 1 offset (bytes</li><li><b>const ss_t *s2</b>:  string 2</li><li><b>const size_t n</b>:  comparison size (bytes)</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_nth_offset">ss_nth_offset</a></b>(<i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Substring offset</li><li><b>const sv_t *offsets</b>: substring offset data</li><li><b>const size_t nth</b>:  n-th element</li><li><b>Return</b> (<i>size_t</i>): Offset in bytes of the n-th element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_nth_size">ss_nth_size</a></b>(<i>const sv_t *offsets</i>, <i>const size_t nth</i>)<br><br><ul><li>Substring size</li><li><b>const sv_t *offsets</b>: substring offset data</li><li><b>const size_t nth</b>:  n-th element</li><li><b>Return</b> (<i>size_t</i>): Size in bytes of the n-th element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_popchar">ss_popchar</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Extract last character from string</li><li><b>ss_t **s</b>: input/output string</li><li><b>Return</b> (<i>int</i>): Extracted character if OK, EOF if empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_printf">ss_printf</a></b>(<i>ss_t **s</i>, <i>size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>printf operation on string</li><li><b>ss_t **s</b>: output string</li><li><b>size_t size</b>:  printf max output size -including the 0 terminator- (bytes)</li><li><b>const char *fmt</b>:  printf "format"</li><li><b>...</b>: printf "format" parameters</li><li><b>Return</b> (<i>int</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_putchar">ss_putchar</a></b>(<i>ss_t **s</i>, <i>const int c</i>)<br><br><ul><li>Append Unicode character to string</li><li><b>ss_t **s</b>: output string</li><li><b>const int c</b>:  Unicode character</li><li><b>Return</b> (<i>int</i>): Echo of the output character or EOF if overflow error</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="ss_read">ss_read</a></b>(<i>ss_t **s</i>, <i>FILE *handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Read from file handle</li><li><b>ss_t **s</b>: output string</li><li><b>FILE *handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ssize_t</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_real_off">ss_real_off</a></b>(<i>const ss_t *s</i>, <i>const size_t off</i>)<br><br><ul><li>Normalize offset: cut offset if bigger than string size</li><li><b>const ss_t *s</b>: string</li><li><b>const size_t off</b>:  offset</li><li><b>Return</b> (<i>size_t</i>): Normalized offset (range: 0..string size)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_replace">ss_replace</a></b>(<i>ss_t **s</i>, <i>const size_t off</i>, <i>const ss_t *s1</i>, <i>const ss_t *s2</i>)<br><br><ul><li>Replace into string</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t off</b>:  byte offset where to start applying the replace operation</li><li><b>const ss_t *s1</b>:  target pattern</li><li><b>const ss_t *s2</b>:  replacement pattern</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_reserve">ss_reserve</a></b>(<i>ss_t **s</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Reserve space for at least N bytes (absolute reserve)</li><li><b>ss_t **s</b>: string</li><li><b>const size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_resize">ss_resize</a></b>(<i>ss_t **s</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Resize string (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t n</b>:  new size in bytes</li><li><b>char fill_byte</b>:  fill byte</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_resize_u">ss_resize_u</a></b>(<i>ss_t **s</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Resize string (Unicode character mode)</li><li><b>ss_t **s</b>: input/output string</li><li><b>const size_t n</b>:  new size in characters</li><li><b>int fill_char</b>:  fill character</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_rtrim">ss_rtrim</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Remove spaces from right side</li><li><b>ss_t **s</b>: input/output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="ss_set_size">ss_set_size</a></b>(<i>ss_t *s</i>, <i>const size_t s</i>)<br><br><ul><li>Set string size (bytes used in UTF8 format)</li><li><b>ss_t *s</b>: string</li><li><b>const size_t s</b>: new size</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="ss_set_turkish_mode">ss_set_turkish_mode</a></b>(<i>const sbool_t enable_turkish_mode</i>)<br><br><ul><li>Set Turkish mode locale (related to case conversion)</li><li><b>const sbool_t enable_turkish_mode</b>: S_TRUE: enable turkish mode, S_FALSE: disable</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: conversion functions OK, S_FALSE: error (missing functions)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_shrink">ss_shrink</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Free unused space</li><li><b>ss_t **s</b>: string</li><li><b>Return</b> (<i>ss_t *</i>): same string (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_size">ss_size</a></b>(<i>const ss_t *s</i>)<br><br><ul><li>Get string size</li><li><b>const ss_t *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): string bytes used in UTF8 format</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_split">ss_split</a></b>(<i>sv_t **offsets</i>, <i>const ss_t *src</i>, <i>const ss_t *separator</i>)<br><br><ul><li>Split/tokenize: break string by separators</li><li><b>sv_t **offsets</b>: output offset structure</li><li><b>const ss_t *src</b>: input string</li><li><b>const ss_t *separator</b>:  separator</li><li><b>Return</b> (<i>size_t</i>): Number of elements</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const char *</i><b><a name="ss_to_c">ss_to_c</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Give a C-compatible zero-ended string reference (byte/UTF-8 mode)</li><li><b>ss_t **s</b>: input string</li><li><b>Return</b> (<i>const char *</i>): Zero-ended C compatible string reference (UTF-8)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const wchar_t *</i><b><a name="ss_to_w">ss_to_w</a></b>(<i>const ss_t *s</i>, <i>wchar_t *o</i>, <i>const size_t nmax</i>, <i>size_t *n</i>)<br><br><ul><li>Give a C-compatible zero-ended string reference ("wide char" Unicode mode)</li><li><b>const ss_t *s</b>: input string</li><li><b>wchar_t *o</b>:  output string buffer</li><li><b>const size_t nmax</b>:  output string max characters</li><li><b>size_t *n</b>:  output string size</li><li><b>Return</b> (<i>const wchar_t *</i>): Zero'ended C compatible string reference ("wide char" Unicode mode)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_tolower">ss_tolower</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Convert string to lowercase</li><li><b>ss_t **s</b>: output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_toupper">ss_toupper</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Convert string to uppercase</li><li><b>ss_t **s</b>: output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ss_t *</i><b><a name="ss_trim">ss_trim</a></b>(<i>ss_t **s</i>)<br><br><ul><li>Remove spaces from left and right side</li><li><b>ss_t **s</b>: input/output string</li><li><b>Return</b> (<i>ss_t *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="ss_write">ss_write</a></b>(<i>FILE *handle</i>, <i>const ss_t *s</i>, <i>const size_t offset</i>, <i>const size_t bytes</i>)<br><br><ul><li>Write to file</li><li><b>FILE *handle</b>: output file</li><li><b>const ss_t *s</b>:  string</li><li><b>const size_t offset</b>:  string offset</li><li><b>const size_t bytes</b>:  bytes to write</li><li><b>Return</b> (<i>ssize_t</i>): written bytes < 0: error</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

