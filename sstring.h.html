<!doctype html><html><title>sstring.h:  string handling
</title><body><h3>sstring.h:  string handling
</h3><br> Provided functions allow efficient operations on strings. Internal
 string format is binary, supporting arbitrary data. Operations
 on strings involving format interpretation, e.g. string length is
 interpreted as UTF-8 when calling to the Unicode function ss_len_u(),
 and as raw data when calling the functions not using Unicode
 interpretation (ss_len()/ss_size()). Strings below 256 bytes take just
 5 bytes for internal structure, and 5 * sizeof(size_t) for bigger
 strings. Unicode size is cached between operations, when possible, so
 in those cases UTF-8 string length computation would be O(1).
<br><br><table><tr><th align="left">&nbsp;<a href="#ss_adler32">ss_adler32</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_printf_va">ss_cat_printf_va</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_url">ss_cpy_enc_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup">ss_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_tolower">ss_dup_tolower</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_get_buffer_r">ss_get_buffer_r</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_adler32r">ss_adler32r</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_read">ss_cat_read</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_xml">ss_cpy_enc_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_c">ss_dup_c</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_toupper">ss_dup_toupper</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_get_buffer_size">ss_get_buffer_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_alloc">ss_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_replace">ss_cat_replace</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_hex">ss_cpy_enc_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_char">ss_dup_char</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_trim">ss_dup_trim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_getchar">ss_getchar</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_alloc_errors">ss_alloc_errors</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_resize">ss_cat_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_lz">ss_cpy_enc_lz</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_cn">ss_dup_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_w">ss_dup_w</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_grow">ss_grow</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_alloca">ss_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_resize_u">ss_cat_resize_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_lzh">ss_cpy_enc_lzh</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_b64">ss_dup_dec_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_wn">ss_dup_wn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_len">ss_len</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_at">ss_at</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_rtrim">ss_cat_rtrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_erase">ss_cpy_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_dquote">ss_dup_dec_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_empty">ss_empty</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_len_u">ss_len_u</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_capacity">ss_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_substr">ss_cat_substr</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_erase_u">ss_cpy_erase_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_json">ss_dup_dec_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_HEX">ss_enc_HEX</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_ltrim">ss_ltrim</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_capacity_left">ss_capacity_left</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_substr_u">ss_cat_substr_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_int">ss_cpy_int</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_squote">ss_dup_dec_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_b64">ss_enc_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_max">ss_max</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat">ss_cat</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_tolower">ss_cat_tolower</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_ltrim">ss_cpy_ltrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_url">ss_dup_dec_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_dquote">ss_enc_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_ncmp">ss_ncmp</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_c">ss_cat_c</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_toupper">ss_cat_toupper</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_printf">ss_cpy_printf</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_esc_xml">ss_dup_dec_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_json">ss_enc_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_ncmpi">ss_ncmpi</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_char">ss_cat_char</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_trim">ss_cat_trim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_printf_va">ss_cpy_printf_va</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_hex">ss_dup_dec_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_squote">ss_enc_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_popchar">ss_popchar</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_cn">ss_cat_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_w">ss_cat_w</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_read">ss_cpy_read</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_dec_lz">ss_dup_dec_lz</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_url">ss_enc_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_printf">ss_printf</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_b64">ss_cat_dec_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cat_wn">ss_cat_wn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_replace">ss_cpy_replace</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_HEX">ss_dup_enc_HEX</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_esc_xml">ss_enc_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_putchar">ss_putchar</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_dquote">ss_cat_dec_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_check">ss_check</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_resize">ss_cpy_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_b64">ss_dup_enc_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_hex">ss_enc_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_read">ss_read</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_json">ss_cat_dec_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_clear">ss_clear</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_resize_u">ss_cpy_resize_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_dquote">ss_dup_enc_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_lz">ss_enc_lz</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_ref">ss_ref</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_squote">ss_cat_dec_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_clear_errors">ss_clear_errors</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_rtrim">ss_cpy_rtrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_json">ss_dup_enc_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_enc_lzh">ss_enc_lzh</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_ref_buf">ss_ref_buf</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_url">ss_cat_dec_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cmp">ss_cmp</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_substr">ss_cpy_substr</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_squote">ss_dup_enc_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_encoding_errors">ss_encoding_errors</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_refa_buf">ss_refa_buf</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_esc_xml">ss_cat_dec_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cmpi">ss_cmpi</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_substr_u">ss_cpy_substr_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_url">ss_dup_enc_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_erase">ss_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_replace">ss_replace</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_hex">ss_cat_dec_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy">ss_cpy</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_tolower">ss_cpy_tolower</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_esc_xml">ss_dup_enc_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_erase_u">ss_erase_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_reserve">ss_reserve</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_dec_lz">ss_cat_dec_lz</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_c">ss_cpy_c</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_toupper">ss_cpy_toupper</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_hex">ss_dup_enc_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_find">ss_find</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_resize">ss_resize</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_HEX">ss_cat_enc_HEX</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_char">ss_cpy_char</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_trim">ss_cpy_trim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_lz">ss_dup_enc_lz</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_find_cn">ss_find_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_resize_u">ss_resize_u</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_b64">ss_cat_enc_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_cn">ss_cpy_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_w">ss_cpy_w</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_enc_lzh">ss_dup_enc_lzh</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findb">ss_findb</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_rtrim">ss_rtrim</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_dquote">ss_cat_enc_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_b64">ss_cpy_dec_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_wn">ss_cpy_wn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_erase">ss_dup_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findc">ss_findc</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_set_turkish_mode">ss_set_turkish_mode</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_json">ss_cat_enc_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_dquote">ss_cpy_dec_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_crc32">ss_crc32</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_erase_u">ss_dup_erase_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findcx">ss_findcx</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_shrink">ss_shrink</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_squote">ss_cat_enc_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_json">ss_cpy_dec_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_crc32r">ss_crc32r</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_int">ss_dup_int</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findnb">ss_findnb</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_size">ss_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_url">ss_cat_enc_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_squote">ss_cpy_dec_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cref">ss_cref</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_ltrim">ss_dup_ltrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findr">ss_findr</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_split">ss_split</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_esc_xml">ss_cat_enc_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_url">ss_cpy_dec_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_crefa">ss_crefa</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_printf">ss_dup_printf</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findr_cn">ss_findr_cn</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_to_c">ss_to_c</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_hex">ss_cat_enc_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_esc_xml">ss_cpy_dec_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_b64">ss_dec_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_printf_va">ss_dup_printf_va</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findrb">ss_findrb</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_to_w">ss_to_w</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_lz">ss_cat_enc_lz</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_hex">ss_cpy_dec_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_dquote">ss_dec_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_read">ss_dup_read</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findrc">ss_findrc</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_tolower">ss_tolower</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_enc_lzh">ss_cat_enc_lzh</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_dec_lz">ss_cpy_dec_lz</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_json">ss_dec_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_replace">ss_dup_replace</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findrcx">ss_findrcx</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_toupper">ss_toupper</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_erase">ss_cat_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_HEX">ss_cpy_enc_HEX</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_squote">ss_dec_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_resize">ss_dup_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findrnb">ss_findrnb</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_trim">ss_trim</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_erase_u">ss_cat_erase_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_b64">ss_cpy_enc_b64</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_url">ss_dec_esc_url</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_resize_u">ss_dup_resize_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findru">ss_findru</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_write">ss_write</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_int">ss_cat_int</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_dquote">ss_cpy_enc_esc_dquote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_esc_xml">ss_dec_esc_xml</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_rtrim">ss_dup_rtrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_findu">ss_findu</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_ltrim">ss_cat_ltrim</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_json">ss_cpy_enc_esc_json</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_hex">ss_dec_hex</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_substr">ss_dup_substr</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_free">ss_free</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#ss_cat_printf">ss_cat_printf</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_cpy_enc_esc_squote">ss_cpy_enc_esc_squote</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dec_lz">ss_dec_lz</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_dup_substr_u">ss_dup_substr_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#ss_get_buffer">ss_get_buffer</a>&nbsp;</th></tr></table><br><br><i>uint32_t </i><b><a name="ss_adler32">ss_adler32</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>String Adler32 checksum</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>uint32_t</i>): 32-bit hash</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="ss_adler32r">ss_adler32r</a></b>(<i>const srt_string *s</i>, <i>uint32_t adler</i>, <i>size_t off1</i>, <i>size_t off2</i>)<br><br><ul><li>Adler32 checksum for substring</li><li><b>const srt_string *s</b>: string</li><li><b>uint32_t adler</b>:  Adler32 resulting from previous chained Adler32 calls (use S_ADLER32_INIT for the first call)</li><li><b>size_t off1</b>:  start offset</li><li><b>size_t off2</b>:  end offset</li><li><b>Return</b> (<i>uint32_t</i>): 32-bit hash</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_alloc">ss_alloc</a></b>(<i>const size_t initial_heap_reserve</i>)<br><br><ul><li>Allocate string (heap)</li><li><b>const size_t initial_heap_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>srt_string *</i>): allocated string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="ss_alloc_errors">ss_alloc_errors</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Check if string had allocation errors</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: has errors; S_FALSE: no errors</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_alloca">ss_alloca</a></b>(<i>const size_t max_size</i>)<br><br><ul><li>Allocate string (stack)</li><li><b>const size_t max_size</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>srt_string *</i>): allocated string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_at">ss_at</a></b>(<i>const srt_string *s</i>, <i>size_t off</i>)<br><br><ul><li>Random access to byte</li><li><b>const srt_string *s</b>: string</li><li><b>size_t off</b>:  offset (bytes)</li><li><b>Return</b> (<i>int</i>): 0..255: byte retrieved ok; < 0: out of range</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_capacity">ss_capacity</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Get allocated space</li><li><b>const srt_string *s</b>: vector</li><li><b>Return</b> (<i>size_t</i>): current allocated space (in bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_capacity_left">ss_capacity_left</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Get preallocated space left</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): allocated space left (in bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat">ss_cat</a></b>(<i>srt_string **s</i>, <i>const srt_string *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate to string one or more strings</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *s1</b>:  input string</li><li><b>...</b>:  optional input strings</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_c">ss_cat_c</a></b>(<i>srt_string **s</i>, <i>const char *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate multiple C strings (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const char *s1</b>:  input string</li><li><b>...</b>:  optional input strings</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_char">ss_cat_char</a></b>(<i>srt_string **s</i>, <i>const int c</i>)<br><br><ul><li>Concatenate string with a string with just one character</li><li><b>srt_string **s</b>: output string</li><li><b>const int c</b>:  input character</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_cn">ss_cat_cn</a></b>(<i>srt_string **s</i>, <i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Concatenate C substring (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const char *src</b>:  input C string</li><li><b>const size_t src_size</b>:  input string size (bytes)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_dec_b64">ss_cat_dec_b64</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string base64 decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_dec_esc_dquote">ss_cat_dec_esc_dquote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string unescaping "" as "</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_dec_esc_json">ss_cat_dec_esc_json</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string JSON escape decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_dec_esc_squote">ss_cat_dec_esc_squote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string unescaping '' as '</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_dec_esc_url">ss_cat_dec_esc_url</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string URL escape decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_dec_esc_xml">ss_cat_dec_esc_xml</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string XML escape decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_dec_hex">ss_cat_dec_hex</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (lowercase) decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_dec_lz">ss_cat_dec_lz</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string LZ decoded copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_HEX">ss_cat_enc_HEX</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (uppercase) encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_b64">ss_cat_enc_b64</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string base64 encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_esc_dquote">ss_cat_enc_esc_dquote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string escaping " as ""</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_esc_json">ss_cat_enc_esc_json</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string JSON escape encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_esc_squote">ss_cat_enc_esc_squote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string escaping ' as ''</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_esc_url">ss_cat_enc_esc_url</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string URL escape encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_esc_xml">ss_cat_enc_esc_xml</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string XML escape encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_hex">ss_cat_enc_hex</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string hexadecimal (lowercase) encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_lz">ss_cat_enc_lz</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string LZ encoded copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_enc_lzh">ss_cat_enc_lzh</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string LZ encoded copy (high compression)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_erase">ss_cat_erase</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate string with erase operation (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t off</b>:  input string byte offset for erase start</li><li><b>const size_t n</b>:  erase count (bytes)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_erase_u">ss_cat_erase_u</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate string with erase operation (Unicode character mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t char_off</b>:  input character string offset for erase start</li><li><b>const size_t n</b>:  erase count (characters)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_int">ss_cat_int</a></b>(<i>srt_string **s</i>, <i>const int64_t num</i>)<br><br><ul><li>Concatenate integer</li><li><b>srt_string **s</b>: output string</li><li><b>const int64_t num</b>:  integer (any signed integer size)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_ltrim">ss_cat_ltrim</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string plus left-trim space removal operation</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_printf">ss_cat_printf</a></b>(<i>srt_string **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Concatenate string with printf operation</li><li><b>srt_string **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  printf parameters</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_printf_va">ss_cat_printf_va</a></b>(<i>srt_string **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Concatenate string with printf_va operation</li><li><b>srt_string **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  printf_va parameters</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_read">ss_cat_read</a></b>(<i>srt_string **s</i>, <i>FILE *handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Cat data read from file handle</li><li><b>srt_string **s</b>: output string</li><li><b>FILE *handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n): WARNING: involves external file I/O</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_replace">ss_cat_replace</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t off</i>, <i>const srt_string *s1</i>, <i>const srt_string *s2</i>)<br><br><ul><li>Concatenate string with replace operation</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t off</b>:  offset for starting the replace operation (0 for the whole input string)</li><li><b>const srt_string *s1</b>:  pattern to be replaced</li><li><b>const srt_string *s2</b>:  patter replacement</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_resize">ss_cat_resize</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Concatenate string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>char fill_byte</b>:  byte for refill</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_resize_u">ss_cat_resize_u</a></b>(<i>srt_string **s</i>, <i>srt_string *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Concatenate string with input string copy plus resize operation (Unicode character)</li><li><b>srt_string **s</b>: output string</li><li><b>srt_string *src</b>:  input string</li><li><b>const size_t n</b>:  number of characters of input string</li><li><b>int fill_char</b>:  character for refill</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_rtrim">ss_cat_rtrim</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string plus right-trim space removal operation</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_substr">ss_cat_substr</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate substring (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t off</b>:  input string substring byte offset</li><li><b>const size_t n</b>:  input string substring size (bytes)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_substr_u">ss_cat_substr_u</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate substring (Unicode character mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t char_off</b>:  input substring character offset</li><li><b>const size_t n</b>:  input string substring size (characters)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_tolower">ss_cat_tolower</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate "lowercased" string</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_toupper">ss_cat_toupper</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate "uppercased" string</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_trim">ss_cat_trim</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Concatenate string with input string plus trim (left and right) space removal operation</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_w">ss_cat_w</a></b>(<i>srt_string **s</i>, <i>const char *s1</i>, <i>...</i>)<br><br><ul><li>Concatenate multiple "wide char" C strings (Unicode character mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const char *s1</b>:  input "wide char" C string (UTF-16 for 16-bit wchar_t, and UTF-32 for 32-bit wchar_t)</li><li><b>...</b>:  optional input "wide char" C strings</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cat_wn">ss_cat_wn</a></b>(<i>srt_string **s</i>, <i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Concatenate "wide char" C substring (Unicode character mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const wchar_t *src</b>:  input "wide char" C string</li><li><b>const size_t src_size</b>:  input string size (characters) (UTF-16 for 16-bit wchar_t, and UTF-32 for 32-bit wchar_t)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_check">ss_check</a></b>(<i>srt_string **s</i>)<br><br><ul><li>Check and fix string (if input string is NULL, replaces it with a empty valid string)</li><li><b>srt_string **s</b>: output string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="ss_clear">ss_clear</a></b>(<i>srt_string *s</i>)<br><br><ul><li>Clear string</li><li><b>srt_string *s</b>: output string</li><li><b>Return</b> (<i>void</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="ss_clear_errors">ss_clear_errors</a></b>(<i>srt_string *s</i>)<br><br><ul><li>Clear allocation/encoding error flags</li><li><b>srt_string *s</b>: string</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_cmp">ss_cmp</a></b>(<i>const srt_string *s1</i>, <i>const srt_string *s2</i>)<br><br><ul><li>String compare</li><li><b>const srt_string *s1</b>: string 1</li><li><b>const srt_string *s2</b>:  string 2</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_cmpi">ss_cmpi</a></b>(<i>const srt_string *s1</i>, <i>const srt_string *s2</i>)<br><br><ul><li>Case-insensitive string compare</li><li><b>const srt_string *s1</b>: string 1</li><li><b>const srt_string *s2</b>:  string 2</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy">ss_cpy</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with a string copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_c">ss_cpy_c</a></b>(<i>srt_string **s</i>, <i>...</i>)<br><br><ul><li>Overwrite string with multiple C string copy (strict aliasing is assumed)</li><li><b>srt_string **s</b>: output string</li><li><b>...</b>:  input strings (one or more C strings)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_char">ss_cpy_char</a></b>(<i>srt_string **s</i>, <i>const int c</i>)<br><br><ul><li>Overwrite string with a string with just one character</li><li><b>srt_string **s</b>: output string</li><li><b>const int c</b>:  input character</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_cn">ss_cpy_cn</a></b>(<i>srt_string **s</i>, <i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Overwrite string with C string copy (strict aliasing is assumed)</li><li><b>srt_string **s</b>: output string</li><li><b>const char *src</b>:  input string</li><li><b>const size_t src_size</b>:  input string bytes</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_dec_b64">ss_cpy_dec_b64</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string base64 decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_dec_esc_dquote">ss_cpy_dec_esc_dquote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string unescaping "" as "</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_dec_esc_json">ss_cpy_dec_esc_json</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string JSON escape decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_dec_esc_squote">ss_cpy_dec_esc_squote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string unescaping '' as '</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_dec_esc_url">ss_cpy_dec_esc_url</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string URL escape decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_dec_esc_xml">ss_cpy_dec_esc_xml</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string XML escape decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_dec_hex">ss_cpy_dec_hex</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (lowercase) decoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_dec_lz">ss_cpy_dec_lz</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string LZ decoded copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_HEX">ss_cpy_enc_HEX</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (uppercase) encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_b64">ss_cpy_enc_b64</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string base64 encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_esc_dquote">ss_cpy_enc_esc_dquote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string escaping " as ""</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_esc_json">ss_cpy_enc_esc_json</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string JSON escape encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_esc_squote">ss_cpy_enc_esc_squote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string escaping ' as ''</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_esc_url">ss_cpy_enc_esc_url</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string URL escape encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_esc_xml">ss_cpy_enc_esc_xml</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string XML escape encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_hex">ss_cpy_enc_hex</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string hexadecimal (lowercase) encoding copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_lz">ss_cpy_enc_lz</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string LZ encoded copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_enc_lzh">ss_cpy_enc_lzh</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string LZ encoded copy (high compression)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_erase">ss_cpy_erase</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with input string copy applying a erase operation (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t off</b>:  input string erase start byte offset</li><li><b>const size_t n</b>:  number of bytes to erase</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_erase_u">ss_cpy_erase_u</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with input string copy applying a erase operation (character mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t char_off</b>:  input string erase start character offset</li><li><b>const size_t n</b>:  number of characters to erase</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_int">ss_cpy_int</a></b>(<i>srt_string **s</i>, <i>const int64_t num</i>)<br><br><ul><li>Overwrite string with integer to string copy</li><li><b>srt_string **s</b>: output string</li><li><b>const int64_t num</b>:  integer (any signed integer size)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_ltrim">ss_cpy_ltrim</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string plus left-trim space removal operation</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_printf">ss_cpy_printf</a></b>(<i>srt_string **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Overwrite string with printf operation</li><li><b>srt_string **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  printf parameters</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_printf_va">ss_cpy_printf_va</a></b>(<i>srt_string **s</i>, <i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Overwrite string with printf_va operation</li><li><b>srt_string **s</b>: output string</li><li><b>const size_t size</b>:  printf output size (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  printf_va parameters</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_read">ss_cpy_read</a></b>(<i>srt_string **s</i>, <i>FILE *handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Read from file handle</li><li><b>srt_string **s</b>: output string</li><li><b>FILE *handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n): WARNING: involves external file I/O</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_replace">ss_cpy_replace</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t off</i>, <i>const srt_string *s1</i>, <i>const srt_string *s2</i>)<br><br><ul><li>Overwrite string with input string plus replace operation</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t off</b>:  offset for starting the replace operation (0 for the whole input string)</li><li><b>const srt_string *s1</b>:  pattern to be replaced</li><li><b>const srt_string *s2</b>:  patter replacement</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_resize">ss_cpy_resize</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Overwrite string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>char fill_byte</b>:  byte for refill</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_resize_u">ss_cpy_resize_u</a></b>(<i>srt_string **s</i>, <i>srt_string *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Overwrite string with input string copy plus resize operation (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: output string</li><li><b>srt_string *src</b>:  input string</li><li><b>const size_t n</b>:  number of bytes of input string</li><li><b>int fill_char</b>:  byte for refill</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_rtrim">ss_cpy_rtrim</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string plus right-trim space removal operation</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_substr">ss_cpy_substr</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with a substring copy (byte mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t off</b>:  input string start offset (bytes)</li><li><b>const size_t n</b>:  number of bytes to be copied</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_substr_u">ss_cpy_substr_u</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite string with a substring copy (character mode)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>const size_t char_off</b>:  input string start offset (characters)</li><li><b>const size_t n</b>:  number of characters to be copied</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_tolower">ss_cpy_tolower</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string lowercase conversion copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_toupper">ss_cpy_toupper</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string uppercase conversion copy</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_trim">ss_cpy_trim</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Overwrite string with input string plus trim (left and right) space removal operation</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_w">ss_cpy_w</a></b>(<i>srt_string **s</i>, <i>...</i>)<br><br><ul><li>Overwrite string with multiple C "wide char" Unicode string copy (strict aliasing is assumed) (UTF-16 for 16-bit wchar_t, and UTF-32 for 32-bit wchar_t)</li><li><b>srt_string **s</b>: output string</li><li><b>...</b>:  input strings (one or more C "wide char" strings)</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_cpy_wn">ss_cpy_wn</a></b>(<i>srt_string **s</i>, <i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Overwrite string with "wide char" Unicode string copy (strict aliasing is assumed) (UTF-16 for 16-bit wchar_t, and UTF-32 for 32-bit wchar_t)</li><li><b>srt_string **s</b>: output string</li><li><b>const wchar_t *src</b>:  input string ("wide char" Unicode)</li><li><b>const size_t src_size</b>:  input string number of characters</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="ss_crc32">ss_crc32</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>String CRC-32 checksum</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>uint32_t</i>): 32-bit hash</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="ss_crc32r">ss_crc32r</a></b>(<i>const srt_string *s</i>, <i>uint32_t crc</i>, <i>size_t off1</i>, <i>size_t off2</i>)<br><br><ul><li>CRC-32 checksum for substring</li><li><b>const srt_string *s</b>: string</li><li><b>uint32_t crc</b>:  CRC resulting from previous chained CRC calls (use S_CRC32_INIT for the first call)</li><li><b>size_t off1</b>:  start offset</li><li><b>size_t off2</b>:  end offset</li><li><b>Return</b> (<i>uint32_t</i>): 32-bit hash</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="ss_cref">ss_cref</a></b>(<i>srt_string_ref *s_ref</i>, <i>const char *c_str</i>)<br><br><ul><li>Create a reference from C string. This is intended for avoid duplicating C strings when working with srt_string functions</li><li><b>srt_string_ref *s_ref</b>: string reference to be built (can be on heap or stack, it is a small structure)</li><li><b>const char *c_str</b>:  input C string (0 terminated ASCII or UTF-8 string)</li><li><b>Return</b> (<i>const srt_string *</i>): srt_string string derived from srt_string_ref</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="ss_crefa">ss_crefa</a></b>(<i>const char *c_str</i>)<br><br><ul><li>Create a reference from C string using implicit stack allocation for the reference handling (be cafeful not using this inside a loop -for loops you can e.g. use ss_build_ref() instead of this, using a local variable allocated in the stack for the reference-)</li><li><b>const char *c_str</b>: input C string (0 terminated ASCII or UTF-8 string)</li><li><b>Return</b> (<i>const srt_string *</i>): srt_string string derived from srt_string_ref</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dec_b64">ss_dec_b64</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Decode from base64</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dec_esc_dquote">ss_dec_esc_dquote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Unescape "" as "</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dec_esc_json">ss_dec_esc_json</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Unescape from JSON encoding</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dec_esc_squote">ss_dec_esc_squote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Unescape '' as '</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dec_esc_url">ss_dec_esc_url</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Unescape from URL encoding</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dec_esc_xml">ss_dec_esc_xml</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Unescape from XML encoding</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dec_hex">ss_dec_hex</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Decode from hexadecimal (lowercase)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dec_lz">ss_dec_lz</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Decode from LZ</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup">ss_dup</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): Output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_c">ss_dup_c</a></b>(<i>const char *src</i>)<br><br><ul><li>Duplicate from C String (ASCII-z)</li><li><b>const char *src</b>: C string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_char">ss_dup_char</a></b>(<i>const int c</i>)<br><br><ul><li>Duplicate string from character</li><li><b>const int c</b>: Unicode character</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_cn">ss_dup_cn</a></b>(<i>const char *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Duplicate from C string</li><li><b>const char *src</b>: C string buffer</li><li><b>const size_t src_size</b>: number of bytes</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_dec_b64">ss_dup_dec_b64</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with base64 decoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_dec_esc_dquote">ss_dup_dec_esc_dquote</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string unescaping "" as "</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_dec_esc_json">ss_dup_dec_esc_json</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with JSON escape decoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_dec_esc_squote">ss_dup_dec_esc_squote</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string unescaping '' as '</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_dec_esc_url">ss_dup_dec_esc_url</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with URL escape decoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_dec_esc_xml">ss_dup_dec_esc_xml</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with XML escape decoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_dec_hex">ss_dup_dec_hex</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with hex decoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_dec_lz">ss_dup_dec_lz</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with LZ decoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_HEX">ss_dup_enc_HEX</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with hex encoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_b64">ss_dup_enc_b64</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with base64 encoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_esc_dquote">ss_dup_enc_esc_dquote</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string escaping " as ""</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_esc_json">ss_dup_enc_esc_json</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with JSON escape encoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_esc_squote">ss_dup_enc_esc_squote</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string escaping ' as ''</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_esc_url">ss_dup_enc_esc_url</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with URL escape encoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_esc_xml">ss_dup_enc_esc_xml</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with XML escape encoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_hex">ss_dup_enc_hex</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with hex encoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_lz">ss_dup_enc_lz</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with LZ encoding</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_enc_lzh">ss_dup_enc_lzh</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with LZ encoding (high compession)</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_erase">ss_dup_erase</a></b>(<i>const srt_string *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from string erasing portion from input</li><li><b>const srt_string *src</b>: string</li><li><b>const size_t off</b>: byte offset</li><li><b>const size_t n</b>: number of bytes</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_erase_u">ss_dup_erase_u</a></b>(<i>const srt_string *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from Unicode "wide char" string erasing portion from input</li><li><b>const srt_string *src</b>: string</li><li><b>const size_t char_off</b>: character offset</li><li><b>const size_t n</b>: number of characters</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_int">ss_dup_int</a></b>(<i>const int64_t num</i>)<br><br><ul><li>Duplicate from integer</li><li><b>const int64_t num</b>: integer</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_ltrim">ss_dup_ltrim</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate and apply trim at left side</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_printf">ss_dup_printf</a></b>(<i>const size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>Duplicate from printf formatting</li><li><b>const size_t size</b>: printf space (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>...</b>:  optional printf parameters</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_printf_va">ss_dup_printf_va</a></b>(<i>const size_t size</i>, <i>const char *fmt</i>, <i>va_list ap</i>)<br><br><ul><li>Duplicate from printf_va formatting</li><li><b>const size_t size</b>: printf_va space (bytes)</li><li><b>const char *fmt</b>:  printf format</li><li><b>va_list ap</b>:  variable argument reference</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_read">ss_dup_read</a></b>(<i>FILE *handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Duplicate from reading from file handle</li><li><b>FILE *handle</b>: file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n): WARNING: involves external file I/O</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_replace">ss_dup_replace</a></b>(<i>const srt_string *src</i>, <i>const size_t off</i>, <i>const srt_string *s1</i>, <i>const srt_string *s2</i>)<br><br><ul><li>Duplicate and apply replace operation after offset</li><li><b>const srt_string *src</b>: string</li><li><b>const size_t off</b>:  offset (bytes)</li><li><b>const srt_string *s1</b>:  needle</li><li><b>const srt_string *s2</b>:  needle replacement</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_resize">ss_dup_resize</a></b>(<i>const srt_string *src</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Duplicate and resize (byte addressing)</li><li><b>const srt_string *src</b>: string</li><li><b>const size_t n</b>:  new size (bytes)</li><li><b>char fill_byte</b>:  fill byte</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_resize_u">ss_dup_resize_u</a></b>(<i>srt_string *src</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Duplicate and resize (Unicode addressing)</li><li><b>srt_string *src</b>: string</li><li><b>const size_t n</b>:  new size (characters)</li><li><b>int fill_char</b>:  fill character</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_rtrim">ss_dup_rtrim</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate and apply trim at right side</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_substr">ss_dup_substr</a></b>(<i>const srt_string *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from substring</li><li><b>const srt_string *src</b>: string</li><li><b>const size_t off</b>: byte offset</li><li><b>const size_t n</b>: number of bytes</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_substr_u">ss_dup_substr_u</a></b>(<i>const srt_string *src</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate from substring</li><li><b>const srt_string *src</b>: string</li><li><b>const size_t char_off</b>: character offset</li><li><b>const size_t n</b>: number of characters</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_tolower">ss_dup_tolower</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with lowercase conversion</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_toupper">ss_dup_toupper</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate string with uppercase conversion</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_trim">ss_dup_trim</a></b>(<i>const srt_string *src</i>)<br><br><ul><li>Duplicate and trim string</li><li><b>const srt_string *src</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_w">ss_dup_w</a></b>(<i>const wchar_t *src</i>)<br><br><ul><li>Duplicate from "wide char" Unicode string (UTF-16 for 16-bit wchar_t, and UTF-32 for 32-bit wchar_t)</li><li><b>const wchar_t *src</b>: "wide char" string</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_dup_wn">ss_dup_wn</a></b>(<i>const wchar_t *src</i>, <i>const size_t src_size</i>)<br><br><ul><li>Duplicate from Unicode "wide char" string (UTF-16 for 16-bit wchar_t, and UTF-32 for 32-bit wchar_t)</li><li><b>const wchar_t *src</b>: "wide char" string</li><li><b>const size_t src_size</b>:  number of characters</li><li><b>Return</b> (<i>srt_string *</i>): output result</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="ss_empty">ss_empty</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Tells if a string is empty (zero elements)</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: empty string; S_FALSE: not empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_HEX">ss_enc_HEX</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert to hexadecimal (uppercase)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_b64">ss_enc_b64</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert to base64</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_esc_dquote">ss_enc_esc_dquote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert/escape escaping " as ""</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_esc_json">ss_enc_esc_json</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert/escape for JSON encoding</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_esc_squote">ss_enc_esc_squote</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert/escape escaping ' as ''</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_esc_url">ss_enc_esc_url</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert/escape for URL encoding</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_esc_xml">ss_enc_esc_xml</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert/escape for XML encoding</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_hex">ss_enc_hex</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert to hexadecimal (lowercase)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_lz">ss_enc_lz</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert to LZ</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_enc_lzh">ss_enc_lzh</a></b>(<i>srt_string **s</i>, <i>const srt_string *src</i>)<br><br><ul><li>Convert to LZ (high compression)</li><li><b>srt_string **s</b>: output string</li><li><b>const srt_string *src</b>:  input string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="ss_encoding_errors">ss_encoding_errors</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Check if string had UTF8 encoding errors</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: has errors; S_FALSE: no errors</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_erase">ss_erase</a></b>(<i>srt_string **s</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Erase portion of a string (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: input/output string</li><li><b>const size_t off</b>:  byte offset where to start the cut</li><li><b>const size_t n</b>:  number of bytes to be cut</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_erase_u">ss_erase_u</a></b>(<i>srt_string **s</i>, <i>const size_t char_off</i>, <i>const size_t n</i>)<br><br><ul><li>Erase portion of a string (Unicode character mode)</li><li><b>srt_string **s</b>: input/output string</li><li><b>const size_t char_off</b>:  character offset where to start the cut</li><li><b>const size_t n</b>:  number of characters to be cut</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_find">ss_find</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const srt_string *tgt</i>)<br><br><ul><li>Find substring into string</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const srt_string *tgt</b>:  target string</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_find_cn">ss_find_cn</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const char *t</i>, <i>const size_t ts</i>)<br><br><ul><li>Find n bytes</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const char *t</b>:  target buffer</li><li><b>const size_t ts</b>:  target buffer size (bytes)</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findb">ss_findb</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>)<br><br><ul><li>Find blank (9, 10, 13, 32) character into string</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findc">ss_findc</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const char c</i>)<br><br><ul><li>Find byte into string</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const char c</b>:  target character</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findcx">ss_findcx</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const unsigned char c_min</i>, <i>const unsigned char c_max</i>)<br><br><ul><li>Find first byte between a min and a max value</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const unsigned char c_min</b>:  target byte mininum value</li><li><b>const unsigned char c_max</b>:  target byte maximum value</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findnb">ss_findnb</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>)<br><br><ul><li>Find non-blank (9, 10, 13, 32) character into string</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findr">ss_findr</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const srt_string *tgt</i>)<br><br><ul><li>Find substring into string (in range)</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const srt_string *tgt</b>:  target string</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findr_cn">ss_findr_cn</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const char *t</i>, <i>const size_t ts</i>)<br><br><ul><li>Find n bytes</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const char *t</b>:  target buffer</li><li><b>const size_t ts</b>:  target buffer size (bytes)</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findrb">ss_findrb</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>)<br><br><ul><li>Find blank (9, 10, 13, 32) character into string (in range)</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findrc">ss_findrc</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const char c</i>)<br><br><ul><li>Find byte into string (in range)</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const char c</b>:  target character</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findrcx">ss_findrcx</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const unsigned char c_min</i>, <i>const unsigned char c_max</i>)<br><br><ul><li>Find first byte between a min and a max value</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const unsigned char c_min</b>:  target byte mininum value</li><li><b>const unsigned char c_max</b>:  target byte maximum value</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findrnb">ss_findrnb</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>)<br><br><ul><li>Find non-blank (9, 10, 13, 32) character into string (in range)</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findru">ss_findru</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const size_t max_off</i>, <i>const int c</i>)<br><br><ul><li>Find Unicode character into string (in range)</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const size_t max_off</b>:  max offset (S_NPOS for end of string)</li><li><b>const int c</b>:  target character</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_findu">ss_findu</a></b>(<i>const srt_string *s</i>, <i>const size_t off</i>, <i>const int c</i>)<br><br><ul><li>Find Unicode character into string</li><li><b>const srt_string *s</b>: input string</li><li><b>const size_t off</b>:  search offset start</li><li><b>const int c</b>:  target character</li><li><b>Return</b> (<i>size_t</i>): Offset location if found, S_NPOS if not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="ss_free">ss_free</a></b>(<i>srt_string **s</i>, <i>...</i>)<br><br><ul><li>Free one or more strings (heap)</li><li><b>srt_string **s</b>: string</li><li><b>...</b>: more strings (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>char *</i><b><a name="ss_get_buffer">ss_get_buffer</a></b>(<i>srt_string *s</i>)<br><br><ul><li>Get string buffer access</li><li><b>srt_string *s</b>: string</li><li><b>Return</b> (<i>char *</i>): pointer to the insternal string buffer (UTF-8 or raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const char *</i><b><a name="ss_get_buffer_r">ss_get_buffer_r</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Get string buffer access (read-only)</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>const char *</i>): pointer to the internal string buffer (UTF-8 or raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_get_buffer_size">ss_get_buffer_size</a></b>(<i>const srt_string *v</i>)<br><br><ul><li>Get string buffer size</li><li><b>const srt_string *v</b>: string</li><li><b>Return</b> (<i>size_t</i>): Number of bytes in use for storing all string characters</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_getchar">ss_getchar</a></b>(<i>const srt_string *s</i>, <i>size_t *autoinc_off</i>)<br><br><ul><li>Get next Unicode character</li><li><b>const srt_string *s</b>: input string</li><li><b>size_t *autoinc_off</b>:  iterator</li><li><b>Return</b> (<i>int</i>): Output character, or EOF if no more characters left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_grow">ss_grow</a></b>(<i>srt_string **s</i>, <i>const size_t extra_elems</i>)<br><br><ul><li>Reserve space for extra elements (relative to current string size)</li><li><b>srt_string **s</b>: string</li><li><b>const size_t extra_elems</b>: number of extra elements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_len">ss_len</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Equivalent to ss_size</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): Number of bytes (UTF-8 string length)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_len_u">ss_len_u</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>String length (Unicode)</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): number of Unicode characters</li><li><b>Time complexity:</b> O(1) if cached, O(n) if not previously computed</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_ltrim">ss_ltrim</a></b>(<i>srt_string **s</i>)<br><br><ul><li>Remove spaces from left side</li><li><b>srt_string **s</b>: input/output string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_max">ss_max</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Get the maximum possible string size</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): max string size (bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_ncmp">ss_ncmp</a></b>(<i>const srt_string *s1</i>, <i>const size_t s1off</i>, <i>const srt_string *s2</i>, <i>const size_t n</i>)<br><br><ul><li>Partial string compare</li><li><b>const srt_string *s1</b>: string 1</li><li><b>const size_t s1off</b>:  string 1 offset (bytes</li><li><b>const srt_string *s2</b>:  string 2</li><li><b>const size_t n</b>:  comparison size (bytes)</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_ncmpi">ss_ncmpi</a></b>(<i>const srt_string *s1</i>, <i>const size_t s1off</i>, <i>const srt_string *s2</i>, <i>const size_t n</i>)<br><br><ul><li>Partial case insensitive string compare</li><li><b>const srt_string *s1</b>: string 1</li><li><b>const size_t s1off</b>:  string 1 offset (bytes</li><li><b>const srt_string *s2</b>:  string 2</li><li><b>const size_t n</b>:  comparison size (bytes)</li><li><b>Return</b> (<i>int</i>): 0: s1 = s2; < 0: s1 lower than s2; > 0: s1 greater than s2</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_popchar">ss_popchar</a></b>(<i>srt_string **s</i>)<br><br><ul><li>Extract last character from string</li><li><b>srt_string **s</b>: input/output string</li><li><b>Return</b> (<i>int</i>): Extracted character if OK, EOF if empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_printf">ss_printf</a></b>(<i>srt_string **s</i>, <i>size_t size</i>, <i>const char *fmt</i>, <i>...</i>)<br><br><ul><li>printf operation on string</li><li><b>srt_string **s</b>: output string</li><li><b>size_t size</b>:  printf max output size -including the 0 terminator- (bytes)</li><li><b>const char *fmt</b>:  printf "format"</li><li><b>...</b>: printf "format" parameters</li><li><b>Return</b> (<i>int</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="ss_putchar">ss_putchar</a></b>(<i>srt_string **s</i>, <i>const int c</i>)<br><br><ul><li>Append Unicode character to string</li><li><b>srt_string **s</b>: output string</li><li><b>const int c</b>:  Unicode character</li><li><b>Return</b> (<i>int</i>): Echo of the output character or EOF if overflow error</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="ss_read">ss_read</a></b>(<i>srt_string **s</i>, <i>FILE *handle</i>, <i>const size_t max_bytes</i>)<br><br><ul><li>Read from file handle</li><li><b>srt_string **s</b>: output string</li><li><b>FILE *handle</b>:  file handle</li><li><b>const size_t max_bytes</b>:  read max size (in bytes)</li><li><b>Return</b> (<i>ssize_t</i>): output result</li><li><b>Time complexity:</b> O(n): WARNING: involves external file I/O</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="ss_ref">ss_ref</a></b>(<i>const srt_string_ref *s_ref</i>)<br><br><ul><li>Get string reference from string reference container</li><li><b>const srt_string_ref *s_ref</b>: string reference container</li><li><b>Return</b> (<i>const srt_string *</i>): srt_string string derived from srt_string_ref</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="ss_ref_buf">ss_ref_buf</a></b>(<i>srt_string_ref *s_ref</i>, <i>const char *buf</i>, <i>const size_t buf_size</i>)<br><br><ul><li>Create a reference from raw data, i.e. not assuming is 0 terminated. WARNING: when using raw references when calling ss_to_c() will return a "" string (safety)), so, if you need a reference to the internal raw buffer use ss_get_buffer_r() instead</li><li><b>srt_string_ref *s_ref</b>: string reference to be built (can be on heap or stack, it is a small structure)</li><li><b>const char *buf</b>: input raw data buffer</li><li><b>const size_t buf_size</b>: input buffer size (bytes)</li><li><b>Return</b> (<i>const srt_string *</i>): srt_string string derived from srt_string_ref</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="ss_refa_buf">ss_refa_buf</a></b>(<i>const char *buf</i>, <i>const size_t buf_size</i>)<br><br><ul><li>Create a reference from raw data, i.e. not 0 terminated, using implicit stack allocation for the reference handling (be cafeful not using this inside a loop -for loops you can e.g. use ss_build_ref() instead of this, using a local variable allocated in the stack for the reference-). WARNING: when using raw references when calling ss_to_c() will return a "" string (safety), so, if you need a reference to the internal raw buffer use ss_get_buffer_r() instead</li><li><b>const char *buf</b>: input raw data buffer</li><li><b>const size_t buf_size</b>: input buffer size (bytes)</li><li><b>Return</b> (<i>const srt_string *</i>): srt_string string derived from srt_string_ref</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_replace">ss_replace</a></b>(<i>srt_string **s</i>, <i>const size_t off</i>, <i>const srt_string *s1</i>, <i>const srt_string *s2</i>)<br><br><ul><li>Replace into string</li><li><b>srt_string **s</b>: input/output string</li><li><b>const size_t off</b>:  byte offset where to start applying the replace operation</li><li><b>const srt_string *s1</b>:  target pattern</li><li><b>const srt_string *s2</b>:  replacement pattern</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_reserve">ss_reserve</a></b>(<i>srt_string **s</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Reserve space for at least N bytes (absolute reserve)</li><li><b>srt_string **s</b>: string</li><li><b>const size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_resize">ss_resize</a></b>(<i>srt_string **s</i>, <i>const size_t n</i>, <i>char fill_byte</i>)<br><br><ul><li>Resize string (byte/UTF-8 mode)</li><li><b>srt_string **s</b>: input/output string</li><li><b>const size_t n</b>:  new size in bytes</li><li><b>char fill_byte</b>:  fill byte</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_resize_u">ss_resize_u</a></b>(<i>srt_string **s</i>, <i>const size_t n</i>, <i>int fill_char</i>)<br><br><ul><li>Resize string (Unicode character mode)</li><li><b>srt_string **s</b>: input/output string</li><li><b>const size_t n</b>:  new size in characters</li><li><b>int fill_char</b>:  fill character</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_rtrim">ss_rtrim</a></b>(<i>srt_string **s</i>)<br><br><ul><li>Remove spaces from right side</li><li><b>srt_string **s</b>: input/output string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="ss_set_turkish_mode">ss_set_turkish_mode</a></b>(<i>const srt_bool enable_turkish_mode</i>)<br><br><ul><li>Set Turkish mode locale (related to case conversion)</li><li><b>const srt_bool enable_turkish_mode</b>: S_TRUE: enable turkish mode, S_FALSE: disable</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: conversion functions OK, S_FALSE: error (missing functions)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_shrink">ss_shrink</a></b>(<i>srt_string **s</i>)<br><br><ul><li>Free unused space</li><li><b>srt_string **s</b>: string</li><li><b>Return</b> (<i>srt_string *</i>): same string (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_size">ss_size</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Get string size</li><li><b>const srt_string *s</b>: string</li><li><b>Return</b> (<i>size_t</i>): string bytes used in UTF8 format</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="ss_split">ss_split</a></b>(<i>const srt_string *src</i>, <i>const srt_string *separator</i>, <i>srt_string_ref out_substrings[]</i>, <i>const size_t max_refs</i>)<br><br><ul><li>Split/tokenize: break string by separators</li><li><b>const srt_string *src</b>: input string</li><li><b>const srt_string *separator</b>:  separator</li><li><b>srt_string_ref out_substrings[]</b>:  output substring references</li><li><b>const size_t max_refs</b>:  number of output substrings</li><li><b>Return</b> (<i>size_t</i>): Number of elements</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const char *</i><b><a name="ss_to_c">ss_to_c</a></b>(<i>const srt_string *s</i>)<br><br><ul><li>Give a C-compatible zero-ended string reference (byte/UTF-8 mode)</li><li><b>const srt_string *s</b>: input string</li><li><b>Return</b> (<i>const char *</i>): Zero-ended C compatible string reference (UTF-8)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const wchar_t *</i><b><a name="ss_to_w">ss_to_w</a></b>(<i>const srt_string *s</i>, <i>wchar_t *o</i>, <i>const size_t nmax</i>, <i>size_t *n</i>)<br><br><ul><li>Give a C-compatible zero-ended string reference ("wide char" Unicode mode) (UTF-16 for 16-bit wchar_t, and UTF-32 for 32-bit wchar_t)</li><li><b>const srt_string *s</b>: input string</li><li><b>wchar_t *o</b>:  output string buffer</li><li><b>const size_t nmax</b>:  output string max characters</li><li><b>size_t *n</b>:  output string size</li><li><b>Return</b> (<i>const wchar_t *</i>): Zero'ended C compatible string reference ("wide char" Unicode mode)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_tolower">ss_tolower</a></b>(<i>srt_string **s</i>)<br><br><ul><li>Convert string to lowercase</li><li><b>srt_string **s</b>: output string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_toupper">ss_toupper</a></b>(<i>srt_string **s</i>)<br><br><ul><li>Convert string to uppercase</li><li><b>srt_string **s</b>: output string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_string *</i><b><a name="ss_trim">ss_trim</a></b>(<i>srt_string **s</i>)<br><br><ul><li>Remove spaces from left and right side</li><li><b>srt_string **s</b>: input/output string</li><li><b>Return</b> (<i>srt_string *</i>): output string reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="ss_write">ss_write</a></b>(<i>FILE *handle</i>, <i>const srt_string *s</i>, <i>const size_t offset</i>, <i>const size_t bytes</i>)<br><br><ul><li>Write to file</li><li><b>FILE *handle</b>: output file</li><li><b>const srt_string *s</b>:  string</li><li><b>const size_t offset</b>:  string offset</li><li><b>const size_t bytes</b>:  bytes to write</li><li><b>Return</b> (<i>ssize_t</i>): written bytes < 0: error</li><li><b>Time complexity:</b> O(n): WARNING: involves external file I/O</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

