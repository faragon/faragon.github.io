<!doctype html><html><body><h3>Documentation for svector.h</h3><br><i>sv_t *</i><b>sv_alloca_t</b>(<i>const enum eSV_Type t</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate typed vector (stack)</li><li><b>const enum eSV_Type t</b>: Vector type: SV_I8/SV_U8/SV_I16/SV_U16/SV_I32/SV_U32/SV_I64/SV_U64</li><li><b>const size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_alloca</b>(<i>const size_t elem_size</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate generic vector (stack)</li><li><b>const size_t elem_size</b>: element size</li><li><b>const size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_alloc</b>(<i>const size_t elem_size</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate generic vector (heap)</li><li><b>const size_t elem_size</b>: element size</li><li><b>const size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_alloc_t</b>(<i>const enum eSV_Type t</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate typed vector (heap)</li><li><b>const enum eSV_Type t</b>: Vector type: SV_I8/SV_U8/SV_I16/SV_U16/SV_I32/SV_U32/SV_I64/SV_U64</li><li><b>const size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b>sv_free</b>(<i>sv_t **c</i>, <i>...</i>)<br><br><ul><li>Free one or more vectors (heap)</li><li><b>sv_t **c</b>: vector</li><li><b>...</b>: more vectors (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_grow</b>(<i>sv_t **c</i>, <i>const size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>sv_t **c</b>: vector</li><li><b>const size_t extra_elems</b>: number of extra eelements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_reserve</b>(<i>sv_t **c</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>sv_t **c</b>: vector</li><li><b>const size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_shrink</b>(<i>sv_t **c</i>)<br><br><ul><li>Free unused space</li><li><b>sv_t **c</b>: vector</li><li><b>Return</b> (<i>sv_t *</i>): same vector (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_size</b>(<i>const sv_t *c</i>)<br><br><ul><li>Get vector size</li><li><b>const sv_t *c</b>: vector</li><li><b>Return</b> (<i>size_t</i>): vector number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b>sv_set_size</b>(<i>sv_t *c</i>, <i>const size_t s</i>)<br><br><ul><li>Set vector size (number of vector elements)</li><li><b>sv_t *c</b>: vector</li><li><b>const size_t s</b>: set vector number of elements</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_len</b>(<i>const sv_t *c</i>)<br><br><ul><li>Equivalent to sv_size</li><li><b>const sv_t *c</b>: vector</li><li><b>Return</b> (<i>size_t</i>): Number of vector elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_alloca</b>(<i>const size_t initial_reserve</i>)<br><br><ul><li>Allocate vector (stack)</li><li><b>const size_t initial_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): allocated vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_capacity</b>(<i>const sv_t *v</i>)<br><br><ul><li>Allocated space</li><li><b>const sv_t *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): current allocated space (vector elements)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_len_left</b>(<i>const sv_t *v</i>)<br><br><ul><li>Preallocated space left</li><li><b>const sv_t *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sv_set_len</b>(<i>sv_t *v</i>, <i>const size_t elems</i>)<br><br><ul><li>Explicit set length (intended for external I/O raw acccess)</li><li><b>sv_t *v</b>: vector</li><li><b>const size_t elems</b>: new length</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: out of range</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void *</i><b>sv_get_buffer</b>(<i>sv_t *v</i>)<br><br><ul><li>Get string buffer read-only access</li><li><b>sv_t *v</b>: string</li><li><b>Return</b> (<i>void *</i>): pointer to the insternal buffer (raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b>sv_get_buffer_r</b>(<i>const sv_t *v</i>)<br><br><ul><li>Get string buffer access</li><li><b>const sv_t *v</b>: string</li><li><b>Return</b> (<i>const void *</i>): pointer to the insternal buffer (raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_get_buffer_size</b>(<i>const sv_t *v</i>)<br><br><ul><li>Get buffer size</li><li><b>const sv_t *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): Number of bytes in use for current vector elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_elem_size</b>(<i>const enum eSV_Type t</i>)<br><br><ul><li>Get vector type element size</li><li><b>const enum eSV_Type t</b>: vector type</li><li><b>Return</b> (<i>size_t</i>): Element size (bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_dup</b>(<i>const sv_t *src</i>)<br><br><ul><li>Duplicate vector</li><li><b>const sv_t *src</b>: vector</li><li><b>Return</b> (<i>sv_t *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [0/4] not reviewed</li></ul><br><br>
<i>sv_t *</i><b>sv_dup_erase</b>(<i>const sv_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate vector portion</li><li><b>const sv_t *src</b>: vector</li><li><b>const size_t off</b>:  offset start</li><li><b>const size_t n</b>:  number of elements to take</li><li><b>Return</b> (<i>sv_t *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_dup_resize</b>(<i>const sv_t *src</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate vector with resize operation</li><li><b>const sv_t *src</b>: vector</li><li><b>const size_t n</b>:  size for the output</li><li><b>Return</b> (<i>sv_t *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_cpy</b>(<i>sv_t **v</i>, <i>const sv_t *src</i>)<br><br><ul><li>Overwrite vector with a vector copy</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_cpy_erase</b>(<i>sv_t **v</i>, <i>const sv_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite vector with input vector copy applying a erase operation</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>const size_t off</b>:  input vector erase start offset</li><li><b>const size_t n</b>:  number of elements to erase</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_cpy_resize</b>(<i>sv_t **v</i>, <i>const sv_t *src</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite vector with input vector copy plus resize operation</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>const size_t n</b>:  number of elements of input vector</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_cat</b>(<i>sv_t **v</i>, <i>const sv_t *v1</i>, <i>...</i>)<br><br><ul><li>Concatenate vectors to vector</li><li><b>sv_t **v</b>: vector</li><li><b>const sv_t *v1</b>:  first vector to be concatenated</li><li><b>...</b>:  optional: N additional vectors to be concatenated</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_cat_erase</b>(<i>sv_t **v</i>, <i>const sv_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate vector with erase operation</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>const size_t off</b>:  input vector offset for erase start</li><li><b>const size_t n</b>:  erase element count</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_cat_resize</b>(<i>sv_t **v</i>, <i>const sv_t *src</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate vector with input vector copy plus resize operation</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>const size_t n</b>:  number of elements of input vector</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_erase</b>(<i>sv_t **v</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Erase portion of a vector</li><li><b>sv_t **v</b>: input/output vector</li><li><b>const size_t off</b>:  element offset where to start the cut</li><li><b>const size_t n</b>:  number of elements to be cut</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b>sv_resize</b>(<i>sv_t **v</i>, <i>const size_t n</i>)<br><br><ul><li>Resize vector</li><li><b>sv_t **v</b>: input/output vector</li><li><b>const size_t n</b>:  new size</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_find</b>(<i>const sv_t *v</i>, <i>const size_t off</i>, <i>const void *target</i>)<br><br><ul><li>Find value in vector (generic data)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t off</b>:  search offset start</li><li><b>const void *target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_find_i</b>(<i>const sv_t *v</i>, <i>const size_t off</i>, <i>const sint_t target</i>)<br><br><ul><li>Find value in vector (integer)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t off</b>:  search offset start</li><li><b>const sint_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b>sv_find_u</b>(<i>const sv_t *v</i>, <i>const size_t off</i>, <i>const suint_t target</i>)<br><br><ul><li>Find value in vector (unsigned integer)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t off</b>:  search offset start</li><li><b>const suint_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b>sv_ncmp</b>(<i>const sv_t *v1</i>, <i>const size_t v1off</i>, <i>const sv_t *v2</i>, <i>const size_t v2off</i>, <i>const size_t n</i>)<br><br><ul><li>Compare two vectors</li><li><b>const sv_t *v1</b>: vector #1</li><li><b>const size_t v1off</b>:  vector #1 offset start</li><li><b>const sv_t *v2</b>:  vector #2</li><li><b>const size_t v2off</b>:  vector #2 start</li><li><b>const size_t n</b>:  compare size</li><li><b>Return</b> (<i>int</i>): 0: equals; < 0 if a < b; > 0 if a > b</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b>sv_at</b>(<i>const sv_t *v</i>, <i>const size_t index</i>)<br><br><ul><li>Vector random access (generic data)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>Return</b> (<i>const void *</i>): NULL: not found; != NULL: element reference</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sint_t </i><b>sv_i_at</b>(<i>const sv_t *v</i>, <i>const size_t index</i>)<br><br><ul><li>Vector random access (integer)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>Return</b> (<i>sint_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>suint_t </i><b>sv_u_at</b>(<i>const sv_t *v</i>, <i>const size_t index</i>)<br><br><ul><li>Vector random access (unsigned integer)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>Return</b> (<i>suint_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sv_push_raw</b>(<i>sv_t **v</i>, <i>const void *src</i>, <i>const size_t n</i>)<br><br><ul><li>Push/add element (generic data)</li><li><b>sv_t **v</b>: vector</li><li><b>const void *src</b>:  data source</li><li><b>const size_t n</b>:  number of elements</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sv_push</b>(<i>sv_t **v</i>, <i>const void *c1</i>, <i>...</i>)<br><br><ul><li>Push/add multiple elements (generic data)</li><li><b>sv_t **v</b>: vector</li><li><b>const void *c1</b>:  new element to be added</li><li><b>...</b>:  more elements to be added (optional)</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sv_push_i</b>(<i>sv_t **v</i>, <i>const sint_t c</i>)<br><br><ul><li>Push/add element (integer)</li><li><b>sv_t **v</b>: vector</li><li><b>const sint_t c</b>:  data source</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sv_push_u</b>(<i>sv_t **v</i>, <i>const suint_t c</i>)<br><br><ul><li>Push/add element (unsigned integer)</li><li><b>sv_t **v</b>: vector</li><li><b>const suint_t c</b>:  data source</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void *</i><b>sv_pop</b>(<i>sv_t *v</i>)<br><br><ul><li>Pop/extract element (generic data)</li><li><b>sv_t *v</b>: vector</li><li><b>Return</b> (<i>void *</i>): Element reference</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sint_t </i><b>sv_pop_i</b>(<i>sv_t *v</i>)<br><br><ul><li>Pop/extract element (integer)</li><li><b>sv_t *v</b>: vector</li><li><b>Return</b> (<i>sint_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

