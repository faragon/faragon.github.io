<!doctype html><html><body><h3>Documentation for svector.h</h3><br><a href="#sv_alloca_t">sv_alloca_t</a><br><a href="#sv_alloca">sv_alloca</a><br><a href="#sv_alloc">sv_alloc</a><br><a href="#sv_alloc_t">sv_alloc_t</a><br><a href="#sv_free">sv_free</a><br><a href="#sv_grow">sv_grow</a><br><a href="#sv_reserve">sv_reserve</a><br><a href="#sv_shrink">sv_shrink</a><br><a href="#sv_size">sv_size</a><br><a href="#sv_set_size">sv_set_size</a><br><a href="#sv_len">sv_len</a><br><a href="#sv_alloca">sv_alloca</a><br><a href="#sv_capacity">sv_capacity</a><br><a href="#sv_len_left">sv_len_left</a><br><a href="#sv_set_len">sv_set_len</a><br><a href="#sv_get_buffer">sv_get_buffer</a><br><a href="#sv_get_buffer_r">sv_get_buffer_r</a><br><a href="#sv_get_buffer_size">sv_get_buffer_size</a><br><a href="#sv_elem_size">sv_elem_size</a><br><a href="#sv_dup">sv_dup</a><br><a href="#sv_dup_erase">sv_dup_erase</a><br><a href="#sv_dup_resize">sv_dup_resize</a><br><a href="#sv_cpy">sv_cpy</a><br><a href="#sv_cpy_erase">sv_cpy_erase</a><br><a href="#sv_cpy_resize">sv_cpy_resize</a><br><a href="#sv_cat">sv_cat</a><br><a href="#sv_cat_erase">sv_cat_erase</a><br><a href="#sv_cat_resize">sv_cat_resize</a><br><a href="#sv_erase">sv_erase</a><br><a href="#sv_resize">sv_resize</a><br><a href="#sv_sort">sv_sort</a><br><a href="#sv_find">sv_find</a><br><a href="#sv_find_i">sv_find_i</a><br><a href="#sv_find_u">sv_find_u</a><br><a href="#sv_ncmp">sv_ncmp</a><br><a href="#sv_cmp">sv_cmp</a><br><a href="#sv_at">sv_at</a><br><a href="#sv_at_i">sv_at_i</a><br><a href="#sv_at_u">sv_at_u</a><br><a href="#sv_set">sv_set</a><br><a href="#sv_set_i">sv_set_i</a><br><a href="#sv_set_u">sv_set_u</a><br><a href="#sv_push_raw">sv_push_raw</a><br><a href="#sv_push">sv_push</a><br><a href="#sv_push_i">sv_push_i</a><br><a href="#sv_push_u">sv_push_u</a><br><a href="#sv_pop">sv_pop</a><br><a href="#sv_pop_i">sv_pop_i</a><br><br><br><i>sv_t *</i><b><a name="sv_alloca_t">sv_alloca_t</a></b>(<i>const enum eSV_Type t</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate typed vector (stack)</li><li><b>const enum eSV_Type t</b>: Vector type: SV_I8/SV_U8/SV_I16/SV_U16/SV_I32/SV_U32/SV_I64/SV_U64</li><li><b>const size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_alloca">sv_alloca</a></b>(<i>const size_t elem_size</i>, <i>const size_t initial_num_elems_reserve</i>, <i>const sv_cmp_t f</i>)<br><br><ul><li>Allocate generic vector (stack)</li><li><b>const size_t elem_size</b>: element size</li><li><b>const size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>const sv_cmp_t f</b>:  compare function (used for sorting, pass NULL for none)</li><li><b>Return</b> (<i>sv_t *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_alloc">sv_alloc</a></b>(<i>const size_t elem_size</i>, <i>const size_t initial_num_elems_reserve</i>, <i>const sv_cmp_t f</i>)<br><br><ul><li>Allocate generic vector (heap)</li><li><b>const size_t elem_size</b>: element size</li><li><b>const size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>const sv_cmp_t f</b>:  compare function (used for sorting, pass NULL for none)</li><li><b>Return</b> (<i>sv_t *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_alloc_t">sv_alloc_t</a></b>(<i>const enum eSV_Type t</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate typed vector (heap)</li><li><b>const enum eSV_Type t</b>: Vector type: SV_I8/SV_U8/SV_I16/SV_U16/SV_I32/SV_U32/SV_I64/SV_U64</li><li><b>const size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sv_free">sv_free</a></b>(<i>sv_t **c</i>, <i>...</i>)<br><br><ul><li>Free one or more vectors (heap)</li><li><b>sv_t **c</b>: vector</li><li><b>...</b>: more vectors (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_grow">sv_grow</a></b>(<i>sv_t **c</i>, <i>const size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>sv_t **c</b>: vector</li><li><b>const size_t extra_elems</b>: number of extra eelements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_reserve">sv_reserve</a></b>(<i>sv_t **c</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>sv_t **c</b>: vector</li><li><b>const size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_shrink">sv_shrink</a></b>(<i>sv_t **c</i>)<br><br><ul><li>Free unused space</li><li><b>sv_t **c</b>: vector</li><li><b>Return</b> (<i>sv_t *</i>): same vector (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_size">sv_size</a></b>(<i>const sv_t *c</i>)<br><br><ul><li>Get vector size</li><li><b>const sv_t *c</b>: vector</li><li><b>Return</b> (<i>size_t</i>): vector number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sv_set_size">sv_set_size</a></b>(<i>sv_t *c</i>, <i>const size_t s</i>)<br><br><ul><li>Set vector size (number of vector elements)</li><li><b>sv_t *c</b>: vector</li><li><b>const size_t s</b>: set vector number of elements</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_len">sv_len</a></b>(<i>const sv_t *c</i>)<br><br><ul><li>Equivalent to sv_size</li><li><b>const sv_t *c</b>: vector</li><li><b>Return</b> (<i>size_t</i>): Number of vector elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_alloca">sv_alloca</a></b>(<i>const size_t initial_reserve</i>)<br><br><ul><li>Allocate vector (stack)</li><li><b>const size_t initial_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): allocated vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_capacity">sv_capacity</a></b>(<i>const sv_t *v</i>)<br><br><ul><li>Allocated space</li><li><b>const sv_t *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): current allocated space (vector elements)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_len_left">sv_len_left</a></b>(<i>const sv_t *v</i>)<br><br><ul><li>Preallocated space left</li><li><b>const sv_t *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sv_set_len">sv_set_len</a></b>(<i>sv_t *v</i>, <i>const size_t elems</i>)<br><br><ul><li>Explicit set length (intended for external I/O raw acccess)</li><li><b>sv_t *v</b>: vector</li><li><b>const size_t elems</b>: new length</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: out of range</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void *</i><b><a name="sv_get_buffer">sv_get_buffer</a></b>(<i>sv_t *v</i>)<br><br><ul><li>Get string buffer read-only access</li><li><b>sv_t *v</b>: string</li><li><b>Return</b> (<i>void *</i>): pointer to the insternal buffer (raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="sv_get_buffer_r">sv_get_buffer_r</a></b>(<i>const sv_t *v</i>)<br><br><ul><li>Get string buffer access</li><li><b>const sv_t *v</b>: string</li><li><b>Return</b> (<i>const void *</i>): pointer to the insternal buffer (raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_get_buffer_size">sv_get_buffer_size</a></b>(<i>const sv_t *v</i>)<br><br><ul><li>Get buffer size</li><li><b>const sv_t *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): Number of bytes in use for current vector elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_elem_size">sv_elem_size</a></b>(<i>const enum eSV_Type t</i>)<br><br><ul><li>Get vector type element size</li><li><b>const enum eSV_Type t</b>: vector type</li><li><b>Return</b> (<i>size_t</i>): Element size (bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_dup">sv_dup</a></b>(<i>const sv_t *src</i>)<br><br><ul><li>Duplicate vector</li><li><b>const sv_t *src</b>: vector</li><li><b>Return</b> (<i>sv_t *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [0/4] not reviewed</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_dup_erase">sv_dup_erase</a></b>(<i>const sv_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate vector portion</li><li><b>const sv_t *src</b>: vector</li><li><b>const size_t off</b>:  offset start</li><li><b>const size_t n</b>:  number of elements to take</li><li><b>Return</b> (<i>sv_t *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_dup_resize">sv_dup_resize</a></b>(<i>const sv_t *src</i>, <i>const size_t n</i>)<br><br><ul><li>Duplicate vector with resize operation</li><li><b>const sv_t *src</b>: vector</li><li><b>const size_t n</b>:  size for the output</li><li><b>Return</b> (<i>sv_t *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_cpy">sv_cpy</a></b>(<i>sv_t **v</i>, <i>const sv_t *src</i>)<br><br><ul><li>Overwrite vector with a vector copy</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_cpy_erase">sv_cpy_erase</a></b>(<i>sv_t **v</i>, <i>const sv_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite vector with input vector copy applying a erase operation</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>const size_t off</b>:  input vector erase start offset</li><li><b>const size_t n</b>:  number of elements to erase</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_cpy_resize">sv_cpy_resize</a></b>(<i>sv_t **v</i>, <i>const sv_t *src</i>, <i>const size_t n</i>)<br><br><ul><li>Overwrite vector with input vector copy plus resize operation</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>const size_t n</b>:  number of elements of input vector</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_cat">sv_cat</a></b>(<i>sv_t **v</i>, <i>const sv_t *v1</i>, <i>...</i>)<br><br><ul><li>Concatenate vectors to vector</li><li><b>sv_t **v</b>: vector</li><li><b>const sv_t *v1</b>:  first vector to be concatenated</li><li><b>...</b>:  optional: N additional vectors to be concatenated</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_cat_erase">sv_cat_erase</a></b>(<i>sv_t **v</i>, <i>const sv_t *src</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate vector with erase operation</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>const size_t off</b>:  input vector offset for erase start</li><li><b>const size_t n</b>:  erase element count</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_cat_resize">sv_cat_resize</a></b>(<i>sv_t **v</i>, <i>const sv_t *src</i>, <i>const size_t n</i>)<br><br><ul><li>Concatenate vector with input vector copy plus resize operation</li><li><b>sv_t **v</b>: output vector</li><li><b>const sv_t *src</b>:  input vector</li><li><b>const size_t n</b>:  number of elements of input vector</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_erase">sv_erase</a></b>(<i>sv_t **v</i>, <i>const size_t off</i>, <i>const size_t n</i>)<br><br><ul><li>Erase portion of a vector</li><li><b>sv_t **v</b>: input/output vector</li><li><b>const size_t off</b>:  element offset where to start the cut</li><li><b>const size_t n</b>:  number of elements to be cut</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_resize">sv_resize</a></b>(<i>sv_t **v</i>, <i>const size_t n</i>)<br><br><ul><li>Resize vector</li><li><b>sv_t **v</b>: input/output vector</li><li><b>const size_t n</b>:  new size</li><li><b>Return</b> (<i>sv_t *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="sv_sort">sv_sort</a></b>(<i>sv_t **v</i>)<br><br><ul><li>Sort vector</li><li><b>sv_t **v</b>: input/output vector</li><li><b>Return</b> (<i>sv_t *</i>): O(n log n) (relies on libc qsort implementation)</li><li><b>Time complexity:</b> 1</li><li><b>Space complexity:</b> 2</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [0/4] not reviewed</li></ul><br><br>
<i>size_t </i><b><a name="sv_find">sv_find</a></b>(<i>const sv_t *v</i>, <i>const size_t off</i>, <i>const void *target</i>)<br><br><ul><li>Find value in vector (generic data)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t off</b>:  search offset start</li><li><b>const void *target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_i">sv_find_i</a></b>(<i>const sv_t *v</i>, <i>const size_t off</i>, <i>const int64_t target</i>)<br><br><ul><li>Find value in vector (integer)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t off</b>:  search offset start</li><li><b>const int64_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_u">sv_find_u</a></b>(<i>const sv_t *v</i>, <i>const size_t off</i>, <i>const uint64_t target</i>)<br><br><ul><li>Find value in vector (unsigned integer)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t off</b>:  search offset start</li><li><b>const uint64_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="sv_ncmp">sv_ncmp</a></b>(<i>const sv_t *v1</i>, <i>const size_t v1off</i>, <i>const sv_t *v2</i>, <i>const size_t v2off</i>, <i>const size_t n</i>)<br><br><ul><li>Compare two vectors [TODO: this may be removed, as it is unnecesary complex]</li><li><b>const sv_t *v1</b>: vector #1</li><li><b>const size_t v1off</b>:  vector #1 offset start</li><li><b>const sv_t *v2</b>:  vector #2</li><li><b>const size_t v2off</b>:  vector #2 start</li><li><b>const size_t n</b>:  compare size</li><li><b>Return</b> (<i>int</i>): 0: equals; < 0 if a < b; > 0 if a > b</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="sv_cmp">sv_cmp</a></b>(<i>const sv_t *v</i>, <i>const size_t a_off</i>, <i>const size_t b_off</i>)<br><br><ul><li>Compare two elements from same vector</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t a_off</b>:  element 'a' offset</li><li><b>const size_t b_off</b>:  element :b' offset</li><li><b>Return</b> (<i>int</i>): 0: equals; < 0 if a < b; > 0 if a > b</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="sv_at">sv_at</a></b>(<i>const sv_t *v</i>, <i>const size_t index</i>)<br><br><ul><li>Vector random access (generic data)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>Return</b> (<i>const void *</i>): NULL: not found; != NULL: element reference</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sv_at_i">sv_at_i</a></b>(<i>const sv_t *v</i>, <i>const size_t index</i>)<br><br><ul><li>Vector random access (integer)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>Return</b> (<i>int64_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint64_t </i><b><a name="sv_at_u">sv_at_u</a></b>(<i>const sv_t *v</i>, <i>const size_t index</i>)<br><br><ul><li>Vector random access (unsigned integer)</li><li><b>const sv_t *v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>Return</b> (<i>uint64_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sv_set">sv_set</a></b>(<i>sv_t **v</i>, <i>const size_t index</i>, <i>const void *value</i>)<br><br><ul><li>Vector random access write (generic data)</li><li><b>sv_t **v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>const void *value</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sv_set_i">sv_set_i</a></b>(<i>sv_t **v</i>, <i>const size_t index</i>, <i>int64_t value</i>)<br><br><ul><li>Vector random access write (integer)</li><li><b>sv_t **v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>int64_t value</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sv_set_u">sv_set_u</a></b>(<i>sv_t **v</i>, <i>const size_t index</i>, <i>uint64_t value</i>)<br><br><ul><li>Vector random access write (unsigned integer)</li><li><b>sv_t **v</b>: vector</li><li><b>const size_t index</b>:  location</li><li><b>uint64_t value</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sv_push_raw">sv_push_raw</a></b>(<i>sv_t **v</i>, <i>const void *src</i>, <i>const size_t n</i>)<br><br><ul><li>Push/add element (generic data)</li><li><b>sv_t **v</b>: vector</li><li><b>const void *src</b>:  data source</li><li><b>const size_t n</b>:  number of elements</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sv_push">sv_push</a></b>(<i>sv_t **v</i>, <i>const void *c1</i>, <i>...</i>)<br><br><ul><li>Push/add multiple elements (generic data)</li><li><b>sv_t **v</b>: vector</li><li><b>const void *c1</b>:  new element to be added</li><li><b>...</b>:  more elements to be added (optional)</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sv_push_i">sv_push_i</a></b>(<i>sv_t **v</i>, <i>const int64_t c</i>)<br><br><ul><li>Push/add element (integer)</li><li><b>sv_t **v</b>: vector</li><li><b>const int64_t c</b>:  data source</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sv_push_u">sv_push_u</a></b>(<i>sv_t **v</i>, <i>const uint64_t c</i>)<br><br><ul><li>Push/add element (unsigned integer)</li><li><b>sv_t **v</b>: vector</li><li><b>const uint64_t c</b>:  data source</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void *</i><b><a name="sv_pop">sv_pop</a></b>(<i>sv_t *v</i>)<br><br><ul><li>Pop/extract element (generic data)</li><li><b>sv_t *v</b>: vector</li><li><b>Return</b> (<i>void *</i>): Element reference</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sv_pop_i">sv_pop_i</a></b>(<i>sv_t *v</i>)<br><br><ul><li>Pop/extract element (integer)</li><li><b>sv_t *v</b>: vector</li><li><b>Return</b> (<i>int64_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

