<!doctype html><html><title>svector.h:  vector handling
</title><body><h3>svector.h:  vector handling
</h3><br> Vector handling functions for managing integer data and
 generic data.
<br> Supported vector types (enum eSV_Type):
<br><br> SV_I8: int8_t
<br> SV_U8: uint8_t
<br> SV_I16: int16_t
<br> SV_U16: uint16_t
<br> SV_I32: int32_t
<br> SV_U32: uint32_t
<br> SV_I64: int64_t
<br> SV_U64: uint64_t
<br> SV_F: float
<br> SV_D: double
<br> SV_GEN: generic-data (user defined)
<br><br><table><tr><th align="left">&nbsp;<a href="#sv_alloc">sv_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_capacity">sv_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_erase">sv_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_get_buffer_size">sv_get_buffer_size</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push">sv_push</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_d">sv_set_d</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_alloc_t">sv_alloc_t</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_capacity_left">sv_capacity_left</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find">sv_find</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_grow">sv_grow</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_d">sv_push_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_f">sv_set_f</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_alloca">sv_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_cat">sv_cat</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_d">sv_find_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_len">sv_len</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_f">sv_push_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_i16">sv_set_i16</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_alloca_t">sv_alloca_t</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_cat_erase">sv_cat_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_f">sv_find_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_ncmp">sv_ncmp</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_i16">sv_push_i16</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_i32">sv_set_i32</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at">sv_at</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_cat_resize">sv_cat_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_i16">sv_find_i16</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop">sv_pop</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_i32">sv_push_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_i64">sv_set_i64</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_d">sv_at_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_clear">sv_clear</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_i32">sv_find_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_d">sv_pop_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_i64">sv_push_i64</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_i8">sv_set_i8</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_f">sv_at_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_cmp">sv_cmp</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_i64">sv_find_i64</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_f">sv_pop_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_i8">sv_push_i8</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_u16">sv_set_u16</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_i16">sv_at_i16</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_cpy">sv_cpy</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_i8">sv_find_i8</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_i16">sv_pop_i16</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_raw">sv_push_raw</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_u32">sv_set_u32</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_i32">sv_at_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_cpy_erase">sv_cpy_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_u16">sv_find_u16</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_i32">sv_pop_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_u16">sv_push_u16</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_u64">sv_set_u64</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_i64">sv_at_i64</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_cpy_resize">sv_cpy_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_u32">sv_find_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_i64">sv_pop_i64</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_u32">sv_push_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set_u8">sv_set_u8</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_i8">sv_at_i8</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_dup">sv_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_u64">sv_find_u64</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_i8">sv_pop_i8</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_u64">sv_push_u64</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_shrink">sv_shrink</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_u16">sv_at_u16</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_dup_erase">sv_dup_erase</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_find_u8">sv_find_u8</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_u16">sv_pop_u16</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_push_u8">sv_push_u8</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_size">sv_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_u32">sv_at_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_dup_resize">sv_dup_resize</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_free">sv_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_u32">sv_pop_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_reserve">sv_reserve</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_sort">sv_sort</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_u64">sv_at_u64</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_elem_size">sv_elem_size</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_get_buffer">sv_get_buffer</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_u64">sv_pop_u64</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_resize">sv_resize</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sv_at_u8">sv_at_u8</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_empty">sv_empty</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_get_buffer_r">sv_get_buffer_r</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_pop_u8">sv_pop_u8</a>&nbsp;</th><th align="left">&nbsp;<a href="#sv_set">sv_set</a>&nbsp;</th></tr></table><br><br><i>srt_vector *</i><b><a name="sv_alloc">sv_alloc</a></b>(<i>size_t elem_size</i>, <i>size_t initial_num_elems_reserve</i>, <i>const srt_vector_cmp f</i>)<br><br><ul><li>Allocate SV_GEN vector (heap)</li><li><b>size_t elem_size</b>: element size</li><li><b>size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>const srt_vector_cmp f</b>:  compare function (used for sorting, pass NULL for none)</li><li><b>Return</b> (<i>srt_vector *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_alloc_t">sv_alloc_t</a></b>(<i>enum eSV_Type t</i>, <i>size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate typed vector (heap)</li><li><b>enum eSV_Type t</b>: Vector type</li><li><b>size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>srt_vector *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_alloca">sv_alloca</a></b>(<i>size_t initial_reserve</i>)<br><br><ul><li>Allocate SV_GEN vector (stack)</li><li><b>size_t initial_reserve</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>srt_vector *</i>): allocated vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_alloca_t">sv_alloca_t</a></b>(<i>enum eSV_Type t</i>, <i>size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate typed vector (stack)</li><li><b>enum eSV_Type t</b>: Vector type</li><li><b>size_t initial_num_elems_reserve</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>srt_vector *</i>): vector</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="sv_at">sv_at</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_GEN)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>const void *</i>): NULL: not found; != NULL: element reference</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>double </i><b><a name="sv_at_d">sv_at_d</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_D)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>double</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>float </i><b><a name="sv_at_f">sv_at_f</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_F)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>float</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int16_t </i><b><a name="sv_at_i16">sv_at_i16</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_I16)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>int16_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="sv_at_i32">sv_at_i32</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_I32)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>int32_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sv_at_i64">sv_at_i64</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_I64)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>int64_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int8_t </i><b><a name="sv_at_i8">sv_at_i8</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_I8)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>int8_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint16_t </i><b><a name="sv_at_u16">sv_at_u16</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_U16)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>uint16_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="sv_at_u32">sv_at_u32</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_U32)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>uint32_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint64_t </i><b><a name="sv_at_u64">sv_at_u64</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_U64)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>uint64_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint8_t </i><b><a name="sv_at_u8">sv_at_u8</a></b>(<i>const srt_vector *v</i>, <i>size_t index</i>)<br><br><ul><li>Vector random access (SV_U8)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>Return</b> (<i>uint8_t</i>): Element value</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_capacity">sv_capacity</a></b>(<i>const srt_vector *v</i>)<br><br><ul><li>Allocated space</li><li><b>const srt_vector *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): current allocated space (vector elements)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_capacity_left">sv_capacity_left</a></b>(<i>const srt_vector *v</i>)<br><br><ul><li>Preallocated space left</li><li><b>const srt_vector *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_cat">sv_cat</a></b>(<i>srt_vector **v</i>, <i>const srt_vector *v1</i>, <i>...</i>)<br><br><ul><li>Concatenate vectors to vector</li><li><b>srt_vector **v</b>: vector</li><li><b>const srt_vector *v1</b>:  first vector to be concatenated</li><li><b>...</b>:  optional: N additional vectors to be concatenated</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_cat_erase">sv_cat_erase</a></b>(<i>srt_vector **v</i>, <i>const srt_vector *src</i>, <i>size_t off</i>, <i>size_t n</i>)<br><br><ul><li>Concatenate vector with erase operation</li><li><b>srt_vector **v</b>: output vector</li><li><b>const srt_vector *src</b>:  input vector</li><li><b>size_t off</b>:  input vector offset for erase start</li><li><b>size_t n</b>:  erase element count</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_cat_resize">sv_cat_resize</a></b>(<i>srt_vector **v</i>, <i>const srt_vector *src</i>, <i>size_t n</i>)<br><br><ul><li>Concatenate vector with input vector copy plus resize operation</li><li><b>srt_vector **v</b>: output vector</li><li><b>const srt_vector *src</b>:  input vector</li><li><b>size_t n</b>:  number of elements of input vector</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sv_clear">sv_clear</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Reset/clean vector (keeping vector type)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="sv_cmp">sv_cmp</a></b>(<i>const srt_vector *v</i>, <i>size_t a_off</i>, <i>size_t b_off</i>)<br><br><ul><li>Compare two elements from same vector</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t a_off</b>:  element 'a' offset</li><li><b>size_t b_off</b>:  element :b' offset</li><li><b>Return</b> (<i>int</i>): 0: equals; < 0 if a < b; > 0 if a > b</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_cpy">sv_cpy</a></b>(<i>srt_vector **v</i>, <i>const srt_vector *src</i>)<br><br><ul><li>Overwrite vector with a vector copy</li><li><b>srt_vector **v</b>: output vector</li><li><b>const srt_vector *src</b>:  input vector</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_cpy_erase">sv_cpy_erase</a></b>(<i>srt_vector **v</i>, <i>const srt_vector *src</i>, <i>size_t off</i>, <i>size_t n</i>)<br><br><ul><li>Overwrite vector with input vector copy applying a erase operation</li><li><b>srt_vector **v</b>: output vector</li><li><b>const srt_vector *src</b>:  input vector</li><li><b>size_t off</b>:  input vector erase start offset</li><li><b>size_t n</b>:  number of elements to erase</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_cpy_resize">sv_cpy_resize</a></b>(<i>srt_vector **v</i>, <i>const srt_vector *src</i>, <i>size_t n</i>)<br><br><ul><li>Overwrite vector with input vector copy plus resize operation</li><li><b>srt_vector **v</b>: output vector</li><li><b>const srt_vector *src</b>:  input vector</li><li><b>size_t n</b>:  number of elements of input vector</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_dup">sv_dup</a></b>(<i>const srt_vector *src</i>)<br><br><ul><li>Duplicate vector</li><li><b>const srt_vector *src</b>: vector</li><li><b>Return</b> (<i>srt_vector *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_dup_erase">sv_dup_erase</a></b>(<i>const srt_vector *src</i>, <i>size_t off</i>, <i>size_t n</i>)<br><br><ul><li>Duplicate vector portion</li><li><b>const srt_vector *src</b>: vector</li><li><b>size_t off</b>:  offset start</li><li><b>size_t n</b>:  number of elements to take</li><li><b>Return</b> (<i>srt_vector *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_dup_resize">sv_dup_resize</a></b>(<i>const srt_vector *src</i>, <i>size_t n</i>)<br><br><ul><li>Duplicate vector with resize operation</li><li><b>const srt_vector *src</b>: vector</li><li><b>size_t n</b>:  size for the output</li><li><b>Return</b> (<i>srt_vector *</i>): output vector</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint8_t </i><b><a name="sv_elem_size">sv_elem_size</a></b>(<i>enum eSV_Type t</i>)<br><br><ul><li>Get vector type element size</li><li><b>enum eSV_Type t</b>: vector type</li><li><b>Return</b> (<i>uint8_t</i>): Element size (bytes)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_empty">sv_empty</a></b>(<i>const srt_vector *v</i>)<br><br><ul><li>Tells if a vector is empty (zero elements)</li><li><b>const srt_vector *v</b>: vector</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: empty vector; S_FALSE: not empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_erase">sv_erase</a></b>(<i>srt_vector **v</i>, <i>size_t off</i>, <i>size_t n</i>)<br><br><ul><li>Erase portion of a vector</li><li><b>srt_vector **v</b>: input/output vector</li><li><b>size_t off</b>:  element offset where to start the cut</li><li><b>size_t n</b>:  number of elements to be cut</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find">sv_find</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>const void *target</i>)<br><br><ul><li>Find value in vector (SV_GEN)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>const void *target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_d">sv_find_d</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>double target</i>)<br><br><ul><li>Find value in vector (SV_D)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>double target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_f">sv_find_f</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>float target</i>)<br><br><ul><li>Find value in vector (SV_F)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>float target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_i16">sv_find_i16</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>int16_t target</i>)<br><br><ul><li>Find value in vector (SV_I16)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>int16_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_i32">sv_find_i32</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>int32_t target</i>)<br><br><ul><li>Find value in vector (SV_I32)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>int32_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_i64">sv_find_i64</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>int64_t target</i>)<br><br><ul><li>Find value in vector (SV_I64)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>int64_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_i8">sv_find_i8</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>int8_t target</i>)<br><br><ul><li>Find value in vector (SV_I8)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>int8_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_u16">sv_find_u16</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>uint16_t target</i>)<br><br><ul><li>Find value in vector (SV_U16)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>uint16_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_u32">sv_find_u32</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>uint32_t target</i>)<br><br><ul><li>Find value in vector (SV_U32)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>uint32_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_u64">sv_find_u64</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>uint64_t target</i>)<br><br><ul><li>Find value in vector (SV_U64)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>uint64_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_find_u8">sv_find_u8</a></b>(<i>const srt_vector *v</i>, <i>size_t off</i>, <i>uint8_t target</i>)<br><br><ul><li>Find value in vector (SV_U8)</li><li><b>const srt_vector *v</b>: vector</li><li><b>size_t off</b>:  search offset start</li><li><b>uint8_t target</b>:  target to be located</li><li><b>Return</b> (<i>size_t</i>): offset: >=0 found; S_NPOS: not found</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sv_free">sv_free</a></b>(<i>srt_vector **v</i>, <i>...</i>)<br><br><ul><li>Free one or more vectors (heap)</li><li><b>srt_vector **v</b>: vector</li><li><b>...</b>: more vectors (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>char *</i><b><a name="sv_get_buffer">sv_get_buffer</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Get vector buffer access</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>char *</i>): pointer to the internal vector buffer (raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const char *</i><b><a name="sv_get_buffer_r">sv_get_buffer_r</a></b>(<i>const srt_vector *v</i>)<br><br><ul><li>Get vector buffer access (read-only)</li><li><b>const srt_vector *v</b>: vector</li><li><b>Return</b> (<i>const char *</i>): pointer to the internal vector buffer (raw data)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_get_buffer_size">sv_get_buffer_size</a></b>(<i>const srt_vector *v</i>)<br><br><ul><li>Get vector buffer size</li><li><b>const srt_vector *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): Number of bytes in use for storing all vector elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_grow">sv_grow</a></b>(<i>srt_vector **v</i>, <i>size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t extra_elems</b>: number of extra eelements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_len">sv_len</a></b>(<i>const srt_vector *v</i>)<br><br><ul><li>Equivalent to sv_size</li><li><b>const srt_vector *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): Number of vector elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int </i><b><a name="sv_ncmp">sv_ncmp</a></b>(<i>const srt_vector *v1</i>, <i>size_t v1off</i>, <i>const srt_vector *v2</i>, <i>size_t v2off</i>, <i>size_t n</i>)<br><br><ul><li>Compare two vectors [TODO: this may be removed, as it is unnecesary complex]</li><li><b>const srt_vector *v1</b>: vector #1</li><li><b>size_t v1off</b>:  vector #1 offset start</li><li><b>const srt_vector *v2</b>:  vector #2</li><li><b>size_t v2off</b>:  vector #2 start</li><li><b>size_t n</b>:  compare size</li><li><b>Return</b> (<i>int</i>): 0: equals; < 0 if a < b; > 0 if a > b</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void *</i><b><a name="sv_pop">sv_pop</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_GEN)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>void *</i>): Element reference</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>double </i><b><a name="sv_pop_d">sv_pop_d</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_D)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>double</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>float </i><b><a name="sv_pop_f">sv_pop_f</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_F)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>float</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int16_t </i><b><a name="sv_pop_i16">sv_pop_i16</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_I16)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>int16_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="sv_pop_i32">sv_pop_i32</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_I32)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>int32_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sv_pop_i64">sv_pop_i64</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_I64)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>int64_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int8_t </i><b><a name="sv_pop_i8">sv_pop_i8</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_I8)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>int8_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint16_t </i><b><a name="sv_pop_u16">sv_pop_u16</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_U16)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>uint16_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="sv_pop_u32">sv_pop_u32</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_U32)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>uint32_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint64_t </i><b><a name="sv_pop_u64">sv_pop_u64</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_U64)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>uint64_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint8_t </i><b><a name="sv_pop_u8">sv_pop_u8</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Pop/extract element (SV_U8)</li><li><b>srt_vector *v</b>: vector</li><li><b>Return</b> (<i>uint8_t</i>): Integer element</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push">sv_push</a></b>(<i>srt_vector **v</i>, <i>const void *c1</i>, <i>...</i>)<br><br><ul><li>Push/add multiple elements (SV_GEN)</li><li><b>srt_vector **v</b>: vector</li><li><b>const void *c1</b>:  new element to be added</li><li><b>...</b>:  more elements to be added (optional)</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_d">sv_push_d</a></b>(<i>srt_vector **v</i>, <i>double c</i>)<br><br><ul><li>Push/add element (SV_D)</li><li><b>srt_vector **v</b>: vector</li><li><b>double c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_f">sv_push_f</a></b>(<i>srt_vector **v</i>, <i>float c</i>)<br><br><ul><li>Push/add element (SV_F)</li><li><b>srt_vector **v</b>: vector</li><li><b>float c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_i16">sv_push_i16</a></b>(<i>srt_vector **v</i>, <i>int16_t c</i>)<br><br><ul><li>Push/add element (SV_I16)</li><li><b>srt_vector **v</b>: vector</li><li><b>int16_t c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_i32">sv_push_i32</a></b>(<i>srt_vector **v</i>, <i>int32_t c</i>)<br><br><ul><li>Push/add element (SV_I32)</li><li><b>srt_vector **v</b>: vector</li><li><b>int32_t c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_i64">sv_push_i64</a></b>(<i>srt_vector **v</i>, <i>int64_t c</i>)<br><br><ul><li>Push/add element (SV_I64)</li><li><b>srt_vector **v</b>: vector</li><li><b>int64_t c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_i8">sv_push_i8</a></b>(<i>srt_vector **v</i>, <i>int8_t c</i>)<br><br><ul><li>Push/add element (SV_I8)</li><li><b>srt_vector **v</b>: vector</li><li><b>int8_t c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_raw">sv_push_raw</a></b>(<i>srt_vector **v</i>, <i>const void *src</i>, <i>size_t n</i>)<br><br><ul><li>Push/add element</li><li><b>srt_vector **v</b>: vector</li><li><b>const void *src</b>:  data source</li><li><b>size_t n</b>:  number of elements</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_u16">sv_push_u16</a></b>(<i>srt_vector **v</i>, <i>uint16_t c</i>)<br><br><ul><li>Push/add element (SV_U16)</li><li><b>srt_vector **v</b>: vector</li><li><b>uint16_t c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_u32">sv_push_u32</a></b>(<i>srt_vector **v</i>, <i>uint32_t c</i>)<br><br><ul><li>Push/add element (SV_U32)</li><li><b>srt_vector **v</b>: vector</li><li><b>uint32_t c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_u64">sv_push_u64</a></b>(<i>srt_vector **v</i>, <i>uint64_t c</i>)<br><br><ul><li>Push/add element (SV_U64)</li><li><b>srt_vector **v</b>: vector</li><li><b>uint64_t c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_push_u8">sv_push_u8</a></b>(<i>srt_vector **v</i>, <i>uint8_t c</i>)<br><br><ul><li>Push/add element (SV_U8)</li><li><b>srt_vector **v</b>: vector</li><li><b>uint8_t c</b>:  data source</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: added OK; S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_reserve">sv_reserve</a></b>(<i>srt_vector **v</i>, <i>size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_resize">sv_resize</a></b>(<i>srt_vector **v</i>, <i>size_t n</i>)<br><br><ul><li>Resize vector</li><li><b>srt_vector **v</b>: input/output vector</li><li><b>size_t n</b>:  new size</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set">sv_set</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>const void *value</i>)<br><br><ul><li>Vector random access write (SV_GEN)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>const void *value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_d">sv_set_d</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>double value</i>)<br><br><ul><li>Vector random access write (SV_D)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>double value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_f">sv_set_f</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>float value</i>)<br><br><ul><li>Vector random access write (SV_F)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>float value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_i16">sv_set_i16</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>int16_t value</i>)<br><br><ul><li>Vector random access write (SV_I16)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>int16_t value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_i32">sv_set_i32</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>int32_t value</i>)<br><br><ul><li>Vector random access write (SV_I32)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>int32_t value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_i64">sv_set_i64</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>int64_t value</i>)<br><br><ul><li>Vector random access write (SV_I64)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>int64_t value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_i8">sv_set_i8</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>int8_t value</i>)<br><br><ul><li>Vector random access write (SV_I8)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>int8_t value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_u16">sv_set_u16</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>uint16_t value</i>)<br><br><ul><li>Vector random access write (SV_U16)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>uint16_t value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_u32">sv_set_u32</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>uint32_t value</i>)<br><br><ul><li>Vector random access write (SV_U32)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>uint32_t value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_u64">sv_set_u64</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>uint64_t value</i>)<br><br><ul><li>Vector random access write (SV_U64)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>uint64_t value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sv_set_u8">sv_set_u8</a></b>(<i>srt_vector **v</i>, <i>size_t index</i>, <i>uint8_t value</i>)<br><br><ul><li>Vector random access write (SV_U8)</li><li><b>srt_vector **v</b>: vector</li><li><b>size_t index</b>:  location</li><li><b>uint8_t value</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: not enough memory</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_shrink">sv_shrink</a></b>(<i>srt_vector **v</i>)<br><br><ul><li>Free unused space</li><li><b>srt_vector **v</b>: vector</li><li><b>Return</b> (<i>srt_vector *</i>): same vector (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sv_size">sv_size</a></b>(<i>const srt_vector *v</i>)<br><br><ul><li>Get vector size</li><li><b>const srt_vector *v</b>: vector</li><li><b>Return</b> (<i>size_t</i>): vector number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_vector *</i><b><a name="sv_sort">sv_sort</a></b>(<i>srt_vector *v</i>)<br><br><ul><li>Sort vector</li><li><b>srt_vector *v</b>: input/output vector</li><li><b>Return</b> (<i>srt_vector *</i>): output vector reference (optional usage)</li><li><b>Time complexity:</b> relies on libc "qsort" implementation, e.g. glibc implements introsort (O(n log n)), musl does smoothsort (O(n log n)), etc.</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

