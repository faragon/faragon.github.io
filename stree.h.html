<!doctype html><html><body><h3>Documentation for stree.h</h3><br><table><tr><th align="left">&nbsp;<a href="#st_alloc">st_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_dup">st_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_grow">st_grow</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_locate">st_locate</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_size">st_size</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_traverse_preorder">st_traverse_preorder</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#st_alloca">st_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_enum">st_enum</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_insert">st_insert</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_reserve">st_reserve</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_traverse_inorder">st_traverse_inorder</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#st_assert">st_assert</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_enum_r">st_enum_r</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_insert_rw">st_insert_rw</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_set_size">st_set_size</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_traverse_levelorder">st_traverse_levelorder</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#st_delete">st_delete</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_free">st_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_len">st_len</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_shrink">st_shrink</a>&nbsp;</th><th align="left">&nbsp;<a href="#st_traverse_postorder">st_traverse_postorder</a>&nbsp;</th></tr></table><br><br><i>st_t *</i><b><a name="st_alloc">st_alloc</a></b>(<i>st_cmp_t cmp_f</i>, <i>const size_t elem_size</i>, <i>const size_t init_size</i>)<br><br><ul><li>Allocate tree (heap)</li><li><b>st_cmp_t cmp_f</b>: compare function</li><li><b>const size_t elem_size</b>: element size</li><li><b>const size_t init_size</b>: space preallocated to store n elements</li><li><b>Return</b> (<i>st_t *</i>): allocated tree</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sv_t *</i><b><a name="st_alloca">st_alloca</a></b>(<i>st_cmp_t cmp_f</i>, <i>const size_t elem_size</i>, <i>const size_t max_size</i>)<br><br><ul><li>Allocate tree (stack)</li><li><b>st_cmp_t cmp_f</b>: node compare function</li><li><b>const size_t elem_size</b>:  node size</li><li><b>const size_t max_size</b>:  space preallocated to store n elements</li><li><b>Return</b> (<i>sv_t *</i>): allocated tree</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="st_assert">st_assert</a></b>(<i>const st_t *t</i>)<br><br><ul><li>Tree check (debug purposes)</li><li><b>const st_t *t</b>: tree</li><li><b>Return</b> (<i>sbool_t</i>): S_TREE: OK, S_FALSE: breaks RB tree rules</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="st_delete">st_delete</a></b>(<i>st_t *t</i>, <i>const stn_t *n</i>, <i>stn_callback_t callback</i>)<br><br><ul><li>Delete tree element</li><li><b>st_t *t</b>: tree</li><li><b>const stn_t *n</b>:  element to delete</li><li><b>stn_callback_t callback</b>:  node delete handling callback (optional if e.g. nodes use no extra dynamic memory references)</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>st_t *</i><b><a name="st_dup">st_dup</a></b>(<i>const st_t *t</i>)<br><br><ul><li>Duplicate tree</li><li><b>const st_t *t</b>: tree</li><li><b>Return</b> (<i>st_t *</i>): output tree</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>stn_t *</i><b><a name="st_enum">st_enum</a></b>(<i>st_t *t</i>, <i>const stndx_t index</i>)<br><br><ul><li>Fast unsorted enumeration</li><li><b>st_t *t</b>: tree</li><li><b>const stndx_t index</b>:  element, 0 to n - 1, being n the number of elements</li><li><b>Return</b> (<i>stn_t *</i>): Reference to the located node; NULL if not found</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const stn_t *</i><b><a name="st_enum_r">st_enum_r</a></b>(<i>const st_t *t</i>, <i>const stndx_t index</i>)<br><br><ul><li>Fast unsorted enumeration (read-only)</li><li><b>const st_t *t</b>: tree</li><li><b>const stndx_t index</b>:  element, 0 to n - 1, being n the number of elements</li><li><b>Return</b> (<i>const stn_t *</i>): Reference to the located node; NULL if not found</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="st_free">st_free</a></b>(<i>st_t **c</i>, <i>...</i>)<br><br><ul><li>Free one or more trees (heap)</li><li><b>st_t **c</b>: tree</li><li><b>...</b>: more trees (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="st_grow">st_grow</a></b>(<i>st_t **c</i>, <i>const size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>st_t **c</b>: tree</li><li><b>const size_t extra_elems</b>: number of extra eelements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="st_insert">st_insert</a></b>(<i>st_t **t</i>, <i>const stn_t *n</i>)<br><br><ul><li>Insert element into tree</li><li><b>st_t **t</b>: tree</li><li><b>const stn_t *n</b>:  element to insert</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: error (not enough memory)</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="st_insert_rw">st_insert_rw</a></b>(<i>st_t **t</i>, <i>const stn_t *n</i>, <i>const st_rewrite_t rw_f</i>)<br><br><ul><li>Insert element into tree, with rewrite function (in case of key already written)</li><li><b>st_t **t</b>: tree</li><li><b>const stn_t *n</b>:  element to insert</li><li><b>const st_rewrite_t rw_f</b>:  rewrite function (if NULL it will behave like st_insert()</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: error (not enough memory)</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="st_len">st_len</a></b>(<i>const st_t *c</i>)<br><br><ul><li>Equivalent to st_size</li><li><b>const st_t *c</b>: tree</li><li><b>Return</b> (<i>size_t</i>): number of tree nodes</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const stn_t *</i><b><a name="st_locate">st_locate</a></b>(<i>const st_t *t</i>, <i>const stn_t *n</i>)<br><br><ul><li>Locate node</li><li><b>const st_t *t</b>: tree</li><li><b>const stn_t *n</b>:  node</li><li><b>Return</b> (<i>const stn_t *</i>): Reference to the located node; NULL if not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="st_reserve">st_reserve</a></b>(<i>st_t **c</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>st_t **c</b>: tree</li><li><b>const size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="st_set_size">st_set_size</a></b>(<i>st_t *c</i>, <i>const size_t s</i>)<br><br><ul><li>Set tree size (for integer-only trees) </li><li><b>st_t *c</b>: tree</li><li><b>const size_t s</b>: set tree number of elements</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>st_t *</i><b><a name="st_shrink">st_shrink</a></b>(<i>st_t **c</i>)<br><br><ul><li>Free unused space</li><li><b>st_t **c</b>: tree</li><li><b>Return</b> (<i>st_t *</i>): same tree (optional usage)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="st_size">st_size</a></b>(<i>const st_t *c</i>)<br><br><ul><li>Get tree size</li><li><b>const st_t *c</b>: tree</li><li><b>Return</b> (<i>size_t</i>): number of tree nodes</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="st_traverse_inorder">st_traverse_inorder</a></b>(<i>const st_t *t</i>, <i>st_traverse f</i>, <i>void *context</i>)<br><br><ul><li>Full tree traversal: in-order</li><li><b>const st_t *t</b>: tree</li><li><b>st_traverse f</b>:  traverse callback</li><li><b>void *context</b>:  callback context</li><li><b>Return</b> (<i>ssize_t</i>): Number of levels stepped down</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="st_traverse_levelorder">st_traverse_levelorder</a></b>(<i>const st_t *t</i>, <i>st_traverse f</i>, <i>void *context</i>)<br><br><ul><li>Bread-first tree traversal</li><li><b>const st_t *t</b>: tree</li><li><b>st_traverse f</b>:  traverse callback</li><li><b>void *context</b>:  callback contest</li><li><b>Return</b> (<i>ssize_t</i>): Number of levels stepped down</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> Aux space: n/2 * sizeof(stndx_t)</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="st_traverse_postorder">st_traverse_postorder</a></b>(<i>const st_t *t</i>, <i>st_traverse f</i>, <i>void *context</i>)<br><br><ul><li>Full tree traversal: post-order</li><li><b>const st_t *t</b>: tree</li><li><b>st_traverse f</b>:  traverse callback</li><li><b>void *context</b>:  callback context</li><li><b>Return</b> (<i>ssize_t</i>): Number of levels stepped down</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="st_traverse_preorder">st_traverse_preorder</a></b>(<i>const st_t *t</i>, <i>st_traverse f</i>, <i>void *context</i>)<br><br><ul><li>Full tree traversal: pre-order</li><li><b>const st_t *t</b>: tree</li><li><b>st_traverse f</b>:  traverse callback</li><li><b>void *context</b>:  callback context</li><li><b>Return</b> (<i>ssize_t</i>): Number of levels stepped down</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

