<!doctype html><html><body><h3>Documentation for smap.h</h3><br><table><tr><th align="left">&nbsp;<a href="#sm_alloc">sm_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_enum">sm_enum</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ii32_insert">sm_ii32_insert</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_is_insert">sm_is_insert</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_si_inc">sm_si_inc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_u_count">sm_u_count</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_alloca">sm_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_enum_r">sm_enum_r</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ii_at">sm_ii_at</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_reserve">sm_reserve</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_si_insert">sm_si_insert</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_uu32_at">sm_uu32_at</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_capacity">sm_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_free">sm_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ii_inc">sm_ii_inc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_reset">sm_reset</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_size">sm_size</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_uu32_inc">sm_uu32_inc</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_capacity_left">sm_capacity_left</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_grow">sm_grow</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ii_insert">sm_ii_insert</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_s_count">sm_s_count</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_sort_to_vectors">sm_sort_to_vectors</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_uu32_insert">sm_uu32_insert</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_cpy">sm_cpy</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_i_count">sm_i_count</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_inorder_enum">sm_inorder_enum</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_s_delete">sm_s_delete</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_sp_at">sm_sp_at</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_dup">sm_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_i_delete">sm_i_delete</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ip_at">sm_ip_at</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_shrink">sm_shrink</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_sp_insert">sm_sp_insert</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_elem_size">sm_elem_size</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ii32_at">sm_ii32_at</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ip_insert">sm_ip_insert</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_shrink">sm_shrink</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ss_at">sm_ss_at</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_empty">sm_empty</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ii32_inc">sm_ii32_inc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_is_at">sm_is_at</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_si_at">sm_si_at</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_ss_insert">sm_ss_insert</a>&nbsp;</th></tr></table><br><br><i>sm_t *</i><b><a name="sm_alloc">sm_alloc</a></b>(<i>const enum eSM_Type t</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate map (heap)</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>const size_t initial_num_elems_reserve</b>:  initial reserve</li><li><b>Return</b> (<i>sm_t *</i>): map</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sm_t *</i><b><a name="sm_alloca">sm_alloca</a></b>(<i>const enum eSM_Type t</i>, <i>const size_t n</i>)<br><br><ul><li>Allocate map (stack)</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>const size_t n</b>:  initial reserve</li><li><b>Return</b> (<i>sm_t *</i>): map</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_capacity">sm_capacity</a></b>(<i>const sm_t *m</i>)<br><br><ul><li>Allocated space</li><li><b>const sm_t *m</b>: map</li><li><b>Return</b> (<i>size_t</i>): current allocated space (vector elements)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_capacity_left">sm_capacity_left</a></b>(<i>const sm_t *m</i>)<br><br><ul><li>Preallocated space left</li><li><b>const sm_t *m</b>: map</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sm_t *</i><b><a name="sm_cpy">sm_cpy</a></b>(<i>sm_t **m</i>, <i>const sm_t *src</i>)<br><br><ul><li>Overwrite map with a map copy</li><li><b>sm_t **m</b>: output map</li><li><b>const sm_t *src</b>:  input map</li><li><b>Return</b> (<i>sm_t *</i>): output map reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sm_t *</i><b><a name="sm_dup">sm_dup</a></b>(<i>const sm_t *src</i>)<br><br><ul><li>Duplicate map</li><li><b>const sm_t *src</b>: input map</li><li><b>Return</b> (<i>sm_t *</i>): output map</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint8_t </i><b><a name="sm_elem_size">sm_elem_size</a></b>(<i>const enum eSM_Type t</i>)<br><br><ul><li>Get map node size from map type</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>Return</b> (<i>uint8_t</i>): bytes required for storing a single node</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_empty">sm_empty</a></b>(<i>const sm_t *m</i>)<br><br><ul><li>Tells if a map is empty (zero elements)</li><li><b>const sm_t *m</b>: map</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: empty vector; S_FALSE: not empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>stn_t *</i><b><a name="sm_enum">sm_enum</a></b>(<i>sm_t *m</i>, <i>const stndx_t i</i>)<br><br><ul><li>Enumerate map elements (unordered)</li><li><b>sm_t *m</b>: map</li><li><b>const stndx_t i</b>:  element, 0 to n - 1, being n the number of elements</li><li><b>Return</b> (<i>stn_t *</i>): Element offset (0..n-1)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>const stn_t *</i><b><a name="sm_enum_r">sm_enum_r</a></b>(<i>const sm_t *m</i>, <i>const stndx_t i</i>)<br><br><ul><li>Enumerate map elements (unordered) (read-only</li><li><b>const sm_t *m</b>: map</li><li><b>const stndx_t i</b>:  element, 0 to n - 1, being n the number of elements</li><li><b>Return</b> (<i>const stn_t *</i>): Element offset (0..n-1)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>void </i><b><a name="sm_free">sm_free</a></b>(<i>sm_t **m</i>, <i>...</i>)<br><br><ul><li>Free one or more maps (heap)</li><li><b>sm_t **m</b>: map</li><li><b>...</b>:  more maps (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_grow">sm_grow</a></b>(<i>sm_t **m</i>, <i>const size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>sm_t **m</b>: map</li><li><b>const size_t extra_elems</b>: number of extra elements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_i_count">sm_i_count</a></b>(<i>const sm_t *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Map element count/check</li><li><b>const sm_t *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_i_delete">sm_i_delete</a></b>(<i>sm_t *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Delete map element</li><li><b>sm_t *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>int32_t </i><b><a name="sm_ii32_at">sm_ii32_at</a></b>(<i>const sm_t *m</i>, <i>const int32_t k</i>)<br><br><ul><li>Access to int32-int32 map</li><li><b>const sm_t *m</b>: map</li><li><b>const int32_t k</b>:  int32 key</li><li><b>Return</b> (<i>int32_t</i>): int32</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_ii32_inc">sm_ii32_inc</a></b>(<i>sm_t **m</i>, <i>const int32_t k</i>, <i>const int32_t v</i>)<br><br><ul><li>Increment value into int32-int32 map</li><li><b>sm_t **m</b>: map</li><li><b>const int32_t k</b>:  key</li><li><b>const int32_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_ii32_insert">sm_ii32_insert</a></b>(<i>sm_t **m</i>, <i>const int32_t k</i>, <i>const int32_t v</i>)<br><br><ul><li>Insert into int32-int32 map</li><li><b>sm_t **m</b>: map</li><li><b>const int32_t k</b>:  key</li><li><b>const int32_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sm_ii_at">sm_ii_at</a></b>(<i>const sm_t *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Access to integer-interger map</li><li><b>const sm_t *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>int64_t</i>): integer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_ii_inc">sm_ii_inc</a></b>(<i>sm_t **m</i>, <i>const int64_t k</i>, <i>const int64_t v</i>)<br><br><ul><li>Increment into int-int map</li><li><b>sm_t **m</b>: map</li><li><b>const int64_t k</b>:  key</li><li><b>const int64_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_ii_insert">sm_ii_insert</a></b>(<i>sm_t **m</i>, <i>const int64_t k</i>, <i>const int64_t v</i>)<br><br><ul><li>Insert into int-int map</li><li><b>sm_t **m</b>: map</li><li><b>const int64_t k</b>:  key</li><li><b>const int64_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="sm_inorder_enum">sm_inorder_enum</a></b>(<i>const sm_t *m</i>, <i>st_traverse f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements using callback (in-order traverse)</li><li><b>const sm_t *m</b>: map</li><li><b>st_traverse f</b>:  traverse function</li><li><b>void *context</b>:  traverse function context</li><li><b>Return</b> (<i>ssize_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>const void *</i><b><a name="sm_ip_at">sm_ip_at</a></b>(<i>const sm_t *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Access to integer-pointer map</li><li><b>const sm_t *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_ip_insert">sm_ip_insert</a></b>(<i>sm_t **m</i>, <i>const int64_t k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into int-pointer map</li><li><b>sm_t **m</b>: map</li><li><b>const int64_t k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const ss_t *</i><b><a name="sm_is_at">sm_is_at</a></b>(<i>const sm_t *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Access to integer-string map</li><li><b>const sm_t *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>const ss_t *</i>): string</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_is_insert">sm_is_insert</a></b>(<i>sm_t **m</i>, <i>const int64_t k</i>, <i>const ss_t *v</i>)<br><br><ul><li>Insert into int-string map</li><li><b>sm_t **m</b>: map</li><li><b>const int64_t k</b>:  key</li><li><b>const ss_t *v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_reserve">sm_reserve</a></b>(<i>sm_t **m</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>sm_t **m</b>: map</li><li><b>const size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_reset">sm_reset</a></b>(<i>sm_t *m</i>)<br><br><ul><li>Reset/clean map (keeping map type)</li><li><b>sm_t *m</b>: map</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: invalid map</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_s_count">sm_s_count</a></b>(<i>const sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Map element count/check</li><li><b>const sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_s_delete">sm_s_delete</a></b>(<i>sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Delete map element</li><li><b>sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sm_t *</i><b><a name="sm_shrink">sm_shrink</a></b>(<i>sm_t **s</i>)<br><br><ul><li>Make the map use the minimum possible memory</li><li><b>sm_t **s</b>: map</li><li><b>Return</b> (<i>sm_t *</i>): map reference (optional usage)</li><li><b>Time complexity:</b> O(1) for allocators using memory remap</li><li><b>Space complexity:</b> O(n) for naive allocators</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sm_t *</i><b><a name="sm_shrink">sm_shrink</a></b>(<i>sm_t **m</i>)<br><br><ul><li>Make the map use the minimum possible memory</li><li><b>sm_t **m</b>: map</li><li><b>Return</b> (<i>sm_t *</i>): map reference (optional usage)</li><li><b>Time complexity:</b> O(1) for allocators using memory remap</li><li><b>Space complexity:</b> O(n) for naive allocators</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sm_si_at">sm_si_at</a></b>(<i>const sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Access to string-integer map</li><li><b>const sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>int64_t</i>): integer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_si_inc">sm_si_inc</a></b>(<i>sm_t **m</i>, <i>const ss_t *k</i>, <i>const int64_t v</i>)<br><br><ul><li>Increment into string-int map</li><li><b>sm_t **m</b>: map</li><li><b>const ss_t *k</b>:  key</li><li><b>const int64_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_si_insert">sm_si_insert</a></b>(<i>sm_t **m</i>, <i>const ss_t *k</i>, <i>const int64_t v</i>)<br><br><ul><li>Insert into string-int map</li><li><b>sm_t **m</b>: map</li><li><b>const ss_t *k</b>:  key</li><li><b>const int64_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_size">sm_size</a></b>(<i>const sm_t *m</i>)<br><br><ul><li>Get map size</li><li><b>const sm_t *m</b>: map</li><li><b>Return</b> (<i>size_t</i>): Map number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>ssize_t </i><b><a name="sm_sort_to_vectors">sm_sort_to_vectors</a></b>(<i>const sm_t *m</i>, <i>sv_t **kv</i>, <i>sv_t **vv</i>)<br><br><ul><li>Sort map to vector</li><li><b>const sm_t *m</b>: map</li><li><b>sv_t **kv</b>:  output vector for keys</li><li><b>sv_t **vv</b>:  output vector for values</li><li><b>Return</b> (<i>ssize_t</i>): Number of map elements</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="sm_sp_at">sm_sp_at</a></b>(<i>const sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Access to string-pointer map</li><li><b>const sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_sp_insert">sm_sp_insert</a></b>(<i>sm_t **m</i>, <i>const ss_t *k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into string-pointer map</li><li><b>sm_t **m</b>: map</li><li><b>const ss_t *k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const ss_t *</i><b><a name="sm_ss_at">sm_ss_at</a></b>(<i>const sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Access to string-string map</li><li><b>const sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>const ss_t *</i>): string</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_ss_insert">sm_ss_insert</a></b>(<i>sm_t **m</i>, <i>const ss_t *k</i>, <i>const ss_t *v</i>)<br><br><ul><li>Insert into string-string map</li><li><b>sm_t **m</b>: map</li><li><b>const ss_t *k</b>:  key</li><li><b>const ss_t *v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_u_count">sm_u_count</a></b>(<i>const sm_t *m</i>, <i>const uint32_t k</i>)<br><br><ul><li>Map element count/check</li><li><b>const sm_t *m</b>: map</li><li><b>const uint32_t k</b>:  32-bit unsigned integer key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="sm_uu32_at">sm_uu32_at</a></b>(<i>const sm_t *m</i>, <i>const uint32_t k</i>)<br><br><ul><li>Access to uint32-uint32 map</li><li><b>const sm_t *m</b>: map</li><li><b>const uint32_t k</b>:  uint32 key</li><li><b>Return</b> (<i>uint32_t</i>): uint32</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_uu32_inc">sm_uu32_inc</a></b>(<i>sm_t **m</i>, <i>const uint32_t k</i>, <i>const uint32_t v</i>)<br><br><ul><li>Increment into uint32-uint32 map</li><li><b>sm_t **m</b>: map</li><li><b>const uint32_t k</b>:  key</li><li><b>const uint32_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b><a name="sm_uu32_insert">sm_uu32_insert</a></b>(<i>sm_t **m</i>, <i>const uint32_t k</i>, <i>const uint32_t v</i>)<br><br><ul><li>Insert into uint32-uint32 map</li><li><b>sm_t **m</b>: map</li><li><b>const uint32_t k</b>:  key</li><li><b>const uint32_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

