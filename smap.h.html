<!doctype html><html><body><h3>Documentation for smap.h</h3><br><i>sm_t *</i><b>sm_alloca</b>(<i>const enum eSM_Type t</i>, <i>const size_t n</i>)<br><br><ul><li>Allocate map (stack)</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>const size_t n</b>:  initial reserve</li><li><b>Return</b> (<i>sm_t *</i>): map</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sm_t *</i><b>sm_alloc</b>(<i>const enum eSM_Type t</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate map (heap)</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>const size_t initial_num_elems_reserve</b>:  initial reserve</li><li><b>Return</b> (<i>sm_t *</i>): map</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sm_t *</i><b>sm_shrink</b>(<i>sm_t **s</i>)<br><br><ul><li>Make the map use the minimum possible memory</li><li><b>sm_t **s</b>: map</li><li><b>Return</b> (<i>sm_t *</i>): map reference (optional usage)</li><li><b>Time complexity:</b> O(1) for allocators using memory remap</li><li><b>Space complexity:</b> O(n) for naive allocators</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>size_t </i><b>sm_elem_size</b>(<i>const enum eSM_Type t</i>)<br><br><ul><li>Get map node size from map type</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>Return</b> (<i>size_t</i>): bytes required for storing a single node</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sm_t *</i><b>sm_dup</b>(<i>const sm_t *src</i>)<br><br><ul><li>Duplicate map</li><li><b>const sm_t *src</b>: input map</li><li><b>Return</b> (<i>sm_t *</i>): output map</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sm_reset</b>(<i>sm_t *m</i>)<br><br><ul><li>Reset/clean map (keeping map type)</li><li><b>sm_t *m</b>: map</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: invalid map</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>void </i><b>sm_set_defaults</b>(<i>sm_t *m</i>, <i>const sint_t i_def_v</i>, <i>const ss_t *s_def_v</i>)<br><br><ul><li>Set map integer and string defaults</li><li><b>sm_t *m</b>: map</li><li><b>const sint_t i_def_v</b>:  integer default</li><li><b>const ss_t *s_def_v</b>:  string default</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>void </i><b>sm_free</b>(<i>sm_t **m</i>, <i>...</i>)<br><br><ul><li>Free one or more maps (heap)</li><li><b>sm_t **m</b>: map</li><li><b>...</b>:  more maps (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>size_t </i><b>sm_size</b>(<i>const sm_t *m</i>)<br><br><ul><li>Get map size</li><li><b>const sm_t *m</b>: map</li><li><b>Return</b> (<i>size_t</i>): Map number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sint32_t </i><b>sm_ii32_at</b>(<i>const sm_t *m</i>, <i>const sint32_t k</i>)<br><br><ul><li>Access to int32-int32 map</li><li><b>const sm_t *m</b>: map</li><li><b>const sint32_t k</b>:  int32 key</li><li><b>Return</b> (<i>sint32_t</i>): int32</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>suint32_t </i><b>sm_uu32_at</b>(<i>const sm_t *m</i>, <i>const suint32_t k</i>)<br><br><ul><li>Access to uint32-uint32 map</li><li><b>const sm_t *m</b>: map</li><li><b>const suint32_t k</b>:  uint32 key</li><li><b>Return</b> (<i>suint32_t</i>): uint32</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sint_t </i><b>sm_ii_at</b>(<i>const sm_t *m</i>, <i>const sint_t k</i>)<br><br><ul><li>Access to integer-interger map</li><li><b>const sm_t *m</b>: map</li><li><b>const sint_t k</b>:  integer key</li><li><b>Return</b> (<i>sint_t</i>): integer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const ss_t *</i><b>sm_is_at</b>(<i>const sm_t *m</i>, <i>const sint_t k</i>)<br><br><ul><li>Access to integer-string map</li><li><b>const sm_t *m</b>: map</li><li><b>const sint_t k</b>:  integer key</li><li><b>Return</b> (<i>const ss_t *</i>): string</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b>sm_ip_at</b>(<i>const sm_t *m</i>, <i>const sint_t k</i>)<br><br><ul><li>Access to integer-pointer map</li><li><b>const sm_t *m</b>: map</li><li><b>const sint_t k</b>:  integer key</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sint_t </i><b>sm_si_at</b>(<i>const sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Access to string-integer map</li><li><b>const sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>sint_t</i>): integer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>const ss_t *</i><b>sm_ss_at</b>(<i>const sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Access to string-string map</li><li><b>const sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>const ss_t *</i>): string</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>const void *</i><b>sm_sp_at</b>(<i>const sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Access to string-pointer map</li><li><b>const sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sm_u_count</b>(<i>const sm_t *m</i>, <i>const suint32_t k</i>)<br><br><ul><li>Map element count/check</li><li><b>const sm_t *m</b>: map</li><li><b>const suint32_t k</b>:  32-bit unsigned integer key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sm_i_count</b>(<i>const sm_t *m</i>, <i>const sint_t k</i>)<br><br><ul><li>Map element count/check</li><li><b>const sm_t *m</b>: map</li><li><b>const sint_t k</b>:  integer key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sm_s_count</b>(<i>const sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Map element count/check</li><li><b>const sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sm_ii32_insert</b>(<i>sm_t **m</i>, <i>const sint32_t k</i>, <i>const sint32_t v</i>)<br><br><ul><li>Insert into int32-int32 map</li><li><b>sm_t **m</b>: map</li><li><b>const sint32_t k</b>:  key</li><li><b>const sint32_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sm_uu32_insert</b>(<i>sm_t **m</i>, <i>const suint32_t k</i>, <i>const suint32_t v</i>)<br><br><ul><li>Insert into uint32-uint32 map</li><li><b>sm_t **m</b>: map</li><li><b>const suint32_t k</b>:  key</li><li><b>const suint32_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sm_ii_insert</b>(<i>sm_t **m</i>, <i>const sint_t k</i>, <i>const sint_t v</i>)<br><br><ul><li>Insert into int-int map</li><li><b>sm_t **m</b>: map</li><li><b>const sint_t k</b>:  key</li><li><b>const sint_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>sbool_t </i><b>sm_is_insert</b>(<i>sm_t **m</i>, <i>const sint_t k</i>, <i>const ss_t *v</i>)<br><br><ul><li>Insert into int-string map</li><li><b>sm_t **m</b>: map</li><li><b>const sint_t k</b>:  key</li><li><b>const ss_t *v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sm_ip_insert</b>(<i>sm_t **m</i>, <i>const sint_t k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into int-pointer map</li><li><b>sm_t **m</b>: map</li><li><b>const sint_t k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sm_si_insert</b>(<i>sm_t **m</i>, <i>const ss_t *k</i>, <i>const sint_t v</i>)<br><br><ul><li>Insert into string-int map</li><li><b>sm_t **m</b>: map</li><li><b>const ss_t *k</b>:  key</li><li><b>const sint_t v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sm_ss_insert</b>(<i>sm_t **m</i>, <i>const ss_t *k</i>, <i>const ss_t *v</i>)<br><br><ul><li>Insert into string-string map</li><li><b>sm_t **m</b>: map</li><li><b>const ss_t *k</b>:  key</li><li><b>const ss_t *v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sm_sp_insert</b>(<i>sm_t **m</i>, <i>const ss_t *k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into string-pointer map</li><li><b>sm_t **m</b>: map</li><li><b>const ss_t *k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sm_i_delete</b>(<i>sm_t *m</i>, <i>const sint_t k</i>)<br><br><ul><li>Delete map element</li><li><b>sm_t *m</b>: map</li><li><b>const sint_t k</b>:  integer key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>sbool_t </i><b>sm_s_delete</b>(<i>sm_t *m</i>, <i>const ss_t *k</i>)<br><br><ul><li>Delete map element</li><li><b>sm_t *m</b>: map</li><li><b>const ss_t *k</b>:  string key</li><li><b>Return</b> (<i>sbool_t</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>stn_t *</i><b>sm_enum</b>(<i>sm_t *m</i>, <i>const stndx_t i</i>)<br><br><ul><li>Enumerate map elements (unordered)</li><li><b>sm_t *m</b>: map</li><li><b>const stndx_t i</b>:  element, 0 to n - 1, being n the number of elements</li><li><b>Return</b> (<i>stn_t *</i>): Element offset (0..n-1)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>const stn_t *</i><b>sm_enum_r</b>(<i>const sm_t *m</i>, <i>const stndx_t i</i>)<br><br><ul><li>Enumerate map elements (unordered) (read-only</li><li><b>const sm_t *m</b>: map</li><li><b>const stndx_t i</b>:  element, 0 to n - 1, being n the number of elements</li><li><b>Return</b> (<i>const stn_t *</i>): Element offset (0..n-1)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ssize_t </i><b>sm_inorder_enum</b>(<i>const sm_t *m</i>, <i>st_traverse f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements using callback (in-order traverse)</li><li><b>const sm_t *m</b>: map</li><li><b>st_traverse f</b>:  traverse function</li><li><b>void *context</b>:  traverse function context</li><li><b>Return</b> (<i>ssize_t</i>): Elements processed</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [0/2] basic (Coverity, clang analyzer)</li><li><b>Quality:</b> [1/4] reviewed, with quality issues</li></ul><br><br>
<i>ssize_t </i><b>sm_sort_to_vectors</b>(<i>const sm_t *m</i>, <i>sv_t **kv</i>, <i>sv_t **vv</i>)<br><br><ul><li>Sort map to vector</li><li><b>const sm_t *m</b>: map</li><li><b>sv_t **kv</b>:  output vector for keys</li><li><b>sv_t **vv</b>:  output vector for values</li><li><b>Return</b> (<i>ssize_t</i>): Number of map elements</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

