<!doctype html><html><title>smap.h:  map handling (key-value storage)
</title><body><h3>smap.h:  map handling (key-value storage)
</h3><br> Map functions handle key-value storage, which is implemented as a
 Red-Black tree (O(n log n) maximum complexity for insert/read/delete).
<br><br> Supported key/value modes (enum eSM_Type):
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SM_II32: 32-bit integer key, 32-bit integer value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SM_UU32: 32-bit unsigned int key, 32-bit unsigned int value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SM_II: 64-bit int key, 64-bit int value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SM_IS: 64-bit int key, string value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SM_IP: 64-bit int key, pointer value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SM_SI: 64-bit string key, 64-bit int value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SM_SS: string key, string value
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SM_SP: string key, pointer value
<br><br> Callback types for the sm_itr_*() functions:
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_map_it_ii32)(int32_t k, int32_t v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_map_it_uu32)(uint32_t k, uint32_t v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_map_it_ii)(int64_t k, int64_t v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_map_it_is)(int64_t k, const srt_string *, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_map_it_ip)(int64_t k, const void *, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_map_it_si)(const srt_string *, int64_t v, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_map_it_ss)(const srt_string *, const srt_string *, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_map_it_sp)(const srt_string *, const void *, void *context);
<br><br><table><tr><th align="left">&nbsp;<a href="#sm_alloc">sm_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_capacity">sm_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_elem_size">sm_elem_size</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_insert_ip">sm_insert_ip</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_ip_v">sm_it_ip_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_itr_ip">sm_itr_ip</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_alloca">sm_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_capacity_left">sm_capacity_left</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_empty">sm_empty</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_insert_is">sm_insert_is</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_is_v">sm_it_is_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_itr_is">sm_itr_is</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_at_ii">sm_at_ii</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_clear">sm_clear</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_free">sm_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_insert_si">sm_insert_si</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_s_k">sm_it_s_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_itr_si">sm_itr_si</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_at_ii32">sm_at_ii32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_count_i">sm_count_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_grow">sm_grow</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_insert_sp">sm_insert_sp</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_si_v">sm_it_si_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_itr_sp">sm_itr_sp</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_at_ip">sm_at_ip</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_count_s">sm_count_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_inc_ii">sm_inc_ii</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_insert_ss">sm_insert_ss</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_sp_v">sm_it_sp_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_itr_ss">sm_itr_ss</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_at_is">sm_at_is</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_count_u">sm_count_u</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_inc_ii32">sm_inc_ii32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_insert_uu32">sm_insert_uu32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_ss_v">sm_it_ss_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_itr_uu32">sm_itr_uu32</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_at_si">sm_at_si</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_cpy">sm_cpy</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_inc_si">sm_inc_si</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_i32_k">sm_it_i32_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_u32_k">sm_it_u32_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_reserve">sm_reserve</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_at_sp">sm_at_sp</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_delete_i">sm_delete_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_inc_uu32">sm_inc_uu32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_i_k">sm_it_i_k</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_uu32_v">sm_it_uu32_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_shrink">sm_shrink</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_at_ss">sm_at_ss</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_delete_s">sm_delete_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_insert_ii">sm_insert_ii</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_ii32_v">sm_it_ii32_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_itr_ii">sm_itr_ii</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_size">sm_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sm_at_uu32">sm_at_uu32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_dup">sm_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_insert_ii32">sm_insert_ii32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_it_ii_v">sm_it_ii_v</a>&nbsp;</th><th align="left">&nbsp;<a href="#sm_itr_ii32">sm_itr_ii32</a>&nbsp;</th></tr></table><br><br><i>srt_map *</i><b><a name="sm_alloc">sm_alloc</a></b>(<i>const enum eSM_Type t</i>, <i>const size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate map (heap)</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>const size_t initial_num_elems_reserve</b>:  initial reserve</li><li><b>Return</b> (<i>srt_map *</i>): map</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_map *</i><b><a name="sm_alloca">sm_alloca</a></b>(<i>const enum eSM_Type t</i>, <i>const size_t n</i>)<br><br><ul><li>Allocate map (stack)</li><li><b>const enum eSM_Type t</b>: map type</li><li><b>const size_t n</b>:  initial reserve</li><li><b>Return</b> (<i>srt_map *</i>): map</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sm_at_ii">sm_at_ii</a></b>(<i>const srt_map *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Access to integer-interger map</li><li><b>const srt_map *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>int64_t</i>): integer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="sm_at_ii32">sm_at_ii32</a></b>(<i>const srt_map *m</i>, <i>const int32_t k</i>)<br><br><ul><li>Access to int32-int32 map</li><li><b>const srt_map *m</b>: map</li><li><b>const int32_t k</b>:  int32 key</li><li><b>Return</b> (<i>int32_t</i>): int32</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="sm_at_ip">sm_at_ip</a></b>(<i>const srt_map *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Access to integer-pointer map</li><li><b>const srt_map *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="sm_at_is">sm_at_is</a></b>(<i>const srt_map *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Access to integer-string map</li><li><b>const srt_map *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sm_at_si">sm_at_si</a></b>(<i>const srt_map *m</i>, <i>const srt_string *k</i>)<br><br><ul><li>Access to string-integer map</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_string *k</b>:  string key</li><li><b>Return</b> (<i>int64_t</i>): integer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="sm_at_sp">sm_at_sp</a></b>(<i>const srt_map *m</i>, <i>const srt_string *k</i>)<br><br><ul><li>Access to string-pointer map</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_string *k</b>:  string key</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="sm_at_ss">sm_at_ss</a></b>(<i>const srt_map *m</i>, <i>const srt_string *k</i>)<br><br><ul><li>Access to string-string map</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_string *k</b>:  string key</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="sm_at_uu32">sm_at_uu32</a></b>(<i>const srt_map *m</i>, <i>const uint32_t k</i>)<br><br><ul><li>Access to uint32-uint32 map</li><li><b>const srt_map *m</b>: map</li><li><b>const uint32_t k</b>:  uint32 key</li><li><b>Return</b> (<i>uint32_t</i>): uint32</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_capacity">sm_capacity</a></b>(<i>const srt_map *m</i>)<br><br><ul><li>Allocated space</li><li><b>const srt_map *m</b>: map</li><li><b>Return</b> (<i>size_t</i>): current allocated space (vector elements)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_capacity_left">sm_capacity_left</a></b>(<i>const srt_map *m</i>)<br><br><ul><li>Preallocated space left</li><li><b>const srt_map *m</b>: map</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sm_clear">sm_clear</a></b>(<i>srt_map *m</i>)<br><br><ul><li>Reset/clean map (keeping map type)</li><li><b>srt_map *m</b>: map</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_count_i">sm_count_i</a></b>(<i>const srt_map *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Map element count/check</li><li><b>const srt_map *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_count_s">sm_count_s</a></b>(<i>const srt_map *m</i>, <i>const srt_string *k</i>)<br><br><ul><li>Map element count/check</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_string *k</b>:  string key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_count_u">sm_count_u</a></b>(<i>const srt_map *m</i>, <i>const uint32_t k</i>)<br><br><ul><li>Map element count/check</li><li><b>const srt_map *m</b>: map</li><li><b>const uint32_t k</b>:  32-bit unsigned integer key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: element found; S_FALSE: not in the map</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_map *</i><b><a name="sm_cpy">sm_cpy</a></b>(<i>srt_map **m</i>, <i>const srt_map *src</i>)<br><br><ul><li>Overwrite map with a map copy</li><li><b>srt_map **m</b>: output map</li><li><b>const srt_map *src</b>:  input map</li><li><b>Return</b> (<i>srt_map *</i>): output map reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_delete_i">sm_delete_i</a></b>(<i>srt_map *m</i>, <i>const int64_t k</i>)<br><br><ul><li>Delete map element</li><li><b>srt_map *m</b>: map</li><li><b>const int64_t k</b>:  integer key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_delete_s">sm_delete_s</a></b>(<i>srt_map *m</i>, <i>const srt_string *k</i>)<br><br><ul><li>Delete map element</li><li><b>srt_map *m</b>: map</li><li><b>const srt_string *k</b>:  string key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_map *</i><b><a name="sm_dup">sm_dup</a></b>(<i>const srt_map *src</i>)<br><br><ul><li>Duplicate map</li><li><b>const srt_map *src</b>: input map</li><li><b>Return</b> (<i>srt_map *</i>): output map</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint8_t </i><b><a name="sm_elem_size">sm_elem_size</a></b>(<i>const int t</i>)<br><br><ul><li>Get map node size from map type</li><li><b>const int t</b>: map type</li><li><b>Return</b> (<i>uint8_t</i>): bytes required for storing a single node</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_empty">sm_empty</a></b>(<i>const srt_map *m</i>)<br><br><ul><li>Tells if a map is empty (zero elements)</li><li><b>const srt_map *m</b>: map</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: empty vector; S_FALSE: not empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sm_free">sm_free</a></b>(<i>srt_map **m</i>, <i>...</i>)<br><br><ul><li>Free one or more maps (heap)</li><li><b>srt_map **m</b>: map</li><li><b>...</b>:  more maps (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple maps, O(n) for maps having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_grow">sm_grow</a></b>(<i>srt_map **m</i>, <i>const size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>srt_map **m</b>: map</li><li><b>const size_t extra_elems</b>: number of extra elements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_inc_ii">sm_inc_ii</a></b>(<i>srt_map **m</i>, <i>const int64_t k</i>, <i>const int64_t v</i>)<br><br><ul><li>Increment into int-int map</li><li><b>srt_map **m</b>: map</li><li><b>const int64_t k</b>:  key</li><li><b>const int64_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_inc_ii32">sm_inc_ii32</a></b>(<i>srt_map **m</i>, <i>const int32_t k</i>, <i>const int32_t v</i>)<br><br><ul><li>Increment value into int32-int32 map</li><li><b>srt_map **m</b>: map</li><li><b>const int32_t k</b>:  key</li><li><b>const int32_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_inc_si">sm_inc_si</a></b>(<i>srt_map **m</i>, <i>const srt_string *k</i>, <i>const int64_t v</i>)<br><br><ul><li>Increment into string-int map</li><li><b>srt_map **m</b>: map</li><li><b>const srt_string *k</b>:  key</li><li><b>const int64_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_inc_uu32">sm_inc_uu32</a></b>(<i>srt_map **m</i>, <i>const uint32_t k</i>, <i>const uint32_t v</i>)<br><br><ul><li>Increment into uint32-uint32 map</li><li><b>srt_map **m</b>: map</li><li><b>const uint32_t k</b>:  key</li><li><b>const uint32_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_insert_ii">sm_insert_ii</a></b>(<i>srt_map **m</i>, <i>const int64_t k</i>, <i>const int64_t v</i>)<br><br><ul><li>Insert into int-int map</li><li><b>srt_map **m</b>: map</li><li><b>const int64_t k</b>:  key</li><li><b>const int64_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_insert_ii32">sm_insert_ii32</a></b>(<i>srt_map **m</i>, <i>const int32_t k</i>, <i>const int32_t v</i>)<br><br><ul><li>Insert into int32-int32 map</li><li><b>srt_map **m</b>: map</li><li><b>const int32_t k</b>:  key</li><li><b>const int32_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_insert_ip">sm_insert_ip</a></b>(<i>srt_map **m</i>, <i>const int64_t k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into int-pointer map</li><li><b>srt_map **m</b>: map</li><li><b>const int64_t k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_insert_is">sm_insert_is</a></b>(<i>srt_map **m</i>, <i>const int64_t k</i>, <i>const srt_string *v</i>)<br><br><ul><li>Insert into int-string map</li><li><b>srt_map **m</b>: map</li><li><b>const int64_t k</b>:  key</li><li><b>const srt_string *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_insert_si">sm_insert_si</a></b>(<i>srt_map **m</i>, <i>const srt_string *k</i>, <i>const int64_t v</i>)<br><br><ul><li>Insert into string-int map</li><li><b>srt_map **m</b>: map</li><li><b>const srt_string *k</b>:  key</li><li><b>const int64_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_insert_sp">sm_insert_sp</a></b>(<i>srt_map **m</i>, <i>const srt_string *k</i>, <i>const void *v</i>)<br><br><ul><li>Insert into string-pointer map</li><li><b>srt_map **m</b>: map</li><li><b>const srt_string *k</b>:  key</li><li><b>const void *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_insert_ss">sm_insert_ss</a></b>(<i>srt_map **m</i>, <i>const srt_string *k</i>, <i>const srt_string *v</i>)<br><br><ul><li>Insert into string-string map</li><li><b>srt_map **m</b>: map</li><li><b>const srt_string *k</b>:  key</li><li><b>const srt_string *v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sm_insert_uu32">sm_insert_uu32</a></b>(<i>srt_map **m</i>, <i>const uint32_t k</i>, <i>const uint32_t v</i>)<br><br><ul><li>Insert into uint32-uint32 map</li><li><b>srt_map **m</b>: map</li><li><b>const uint32_t k</b>:  key</li><li><b>const uint32_t v</b>:  value</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="sm_it_i32_k">sm_it_i32_k</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate int32-* map keys</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int32_t</i>): int32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sm_it_i_k">sm_it_i_k</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate integer-* map keys</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int64_t</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="sm_it_ii32_v">sm_it_ii32_v</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate int32-int32 map values</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int32_t</i>): int32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sm_it_ii_v">sm_it_ii_v</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate integer-interger map values</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int64_t</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="sm_it_ip_v">sm_it_ip_v</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate integer-pointer map values</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="sm_it_is_v">sm_it_is_v</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate integer-string map values</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="sm_it_s_k">sm_it_s_k</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate string-* map keys</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int64_t </i><b><a name="sm_it_si_v">sm_it_si_v</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate string-integer map values</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int64_t</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const void *</i><b><a name="sm_it_sp_v">sm_it_sp_v</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate string-pointer map</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const void *</i>): pointer</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>const srt_string *</i><b><a name="sm_it_ss_v">sm_it_ss_v</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate string-string map values</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>const srt_string *</i>): string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="sm_it_u32_k">sm_it_u32_k</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate uint32-* map keys</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>uint32_t</i>): uint32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="sm_it_uu32_v">sm_it_uu32_v</a></b>(<i>const srt_map *m</i>, <i>const srt_tndx i</i>)<br><br><ul><li>Enumerate uint32-uint32 map values</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>uint32_t</i>): uint32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_itr_ii">sm_itr_ii</a></b>(<i>const srt_map *m</i>, <i>int64_t key_min</i>, <i>int64_t key_max</i>, <i>srt_map_it_ii f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in a given key range</li><li><b>const srt_map *m</b>: map</li><li><b>int64_t key_min</b>:  key lower bound</li><li><b>int64_t key_max</b>:  key upper bound</li><li><b>srt_map_it_ii f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_itr_ii32">sm_itr_ii32</a></b>(<i>const srt_map *m</i>, <i>int32_t key_min</i>, <i>int32_t key_max</i>, <i>srt_map_it_ii32 f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in a given key range</li><li><b>const srt_map *m</b>: map</li><li><b>int32_t key_min</b>:  key lower bound</li><li><b>int32_t key_max</b>:  key upper bound</li><li><b>srt_map_it_ii32 f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_itr_ip">sm_itr_ip</a></b>(<i>const srt_map *m</i>, <i>int64_t key_min</i>, <i>int64_t key_max</i>, <i>srt_map_it_ip f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in a given key range</li><li><b>const srt_map *m</b>: map</li><li><b>int64_t key_min</b>:  key lower bound</li><li><b>int64_t key_max</b>:  key upper bound</li><li><b>srt_map_it_ip f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_itr_is">sm_itr_is</a></b>(<i>const srt_map *m</i>, <i>int64_t key_min</i>, <i>int64_t key_max</i>, <i>srt_map_it_is f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in a given key range</li><li><b>const srt_map *m</b>: map</li><li><b>int64_t key_min</b>:  key lower bound</li><li><b>int64_t key_max</b>:  key upper bound</li><li><b>srt_map_it_is f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_itr_si">sm_itr_si</a></b>(<i>const srt_map *m</i>, <i>const srt_string *key_min</i>, <i>const srt_string *key_max</i>, <i>srt_map_it_si f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in a given key range</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_string *key_min</b>:  key lower bound</li><li><b>const srt_string *key_max</b>:  key upper bound</li><li><b>srt_map_it_si f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_itr_sp">sm_itr_sp</a></b>(<i>const srt_map *m</i>, <i>const srt_string *key_min</i>, <i>const srt_string *key_max</i>, <i>srt_map_it_sp f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in a given key range</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_string *key_min</b>:  key lower bound</li><li><b>const srt_string *key_max</b>:  key upper bound</li><li><b>srt_map_it_sp f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_itr_ss">sm_itr_ss</a></b>(<i>const srt_map *m</i>, <i>const srt_string *key_min</i>, <i>const srt_string *key_max</i>, <i>srt_map_it_ss f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in a given key range</li><li><b>const srt_map *m</b>: map</li><li><b>const srt_string *key_min</b>:  key lower bound</li><li><b>const srt_string *key_max</b>:  key upper bound</li><li><b>srt_map_it_ss f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_itr_uu32">sm_itr_uu32</a></b>(<i>const srt_map *m</i>, <i>uint32_t key_min</i>, <i>uint32_t key_max</i>, <i>srt_map_it_uu32 f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate map elements in a given key range</li><li><b>const srt_map *m</b>: map</li><li><b>uint32_t key_min</b>:  key lower bound</li><li><b>uint32_t key_max</b>:  key upper bound</li><li><b>srt_map_it_uu32 f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_reserve">sm_reserve</a></b>(<i>srt_map **m</i>, <i>const size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>srt_map **m</b>: map</li><li><b>const size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_map *</i><b><a name="sm_shrink">sm_shrink</a></b>(<i>srt_map **m</i>)<br><br><ul><li>Make the map use the minimum possible memory</li><li><b>srt_map **m</b>: map</li><li><b>Return</b> (<i>srt_map *</i>): map reference (optional usage)</li><li><b>Time complexity:</b> O(1) for allocators using memory remap</li><li><b>Space complexity:</b> O(n) for naive allocators</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sm_size">sm_size</a></b>(<i>const srt_map *m</i>)<br><br><ul><li>Get map size</li><li><b>const srt_map *m</b>: map</li><li><b>Return</b> (<i>size_t</i>): Map number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

