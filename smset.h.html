<!doctype html><html><title>smset.h:  set handling (key-only storage)
</title><body><h3>smset.h:  set handling (key-only storage)
</h3><br> Set functions handle key-only storage, which is implemented as a
 Red-Black tree (O(n log n) maximum complexity for insert/read/delete).
<br><br> Supported set modes (enum eSMS_Type):
<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SMS_I32: int32_t key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SMS_U32: uint32_t key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SMS_I: int64_t key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SMS_F: float (single-precision floating point) key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SMS_D: double (double-precision floating point) key
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SMS_S: string key
<br><br> Callback types for the sm_itr_*() functions:
<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_set_it_i32)(int32_t k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_set_it_u32)(uint32_t k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_set_it_i)(int64_t k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_set_it_f)(float k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_set_it_d)(double k, void *context);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef srt_bool (*srt_set_it_s)(const srt_string *, void *context);
<br><br><table><tr><th align="left">&nbsp;<a href="#sms_alloc">sms_alloc</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_count_i32">sms_count_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_delete_s">sms_delete_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_insert_i">sms_insert_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_it_s">sms_it_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_reserve">sms_reserve</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sms_alloca">sms_alloca</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_count_s">sms_count_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_delete_u32">sms_delete_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_insert_i32">sms_insert_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_it_u32">sms_it_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_shrink">sms_shrink</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sms_capacity">sms_capacity</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_count_u32">sms_count_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_dup">sms_dup</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_insert_s">sms_insert_s</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_itr_d">sms_itr_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_size">sms_size</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sms_capacity_left">sms_capacity_left</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_cpy">sms_cpy</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_empty">sms_empty</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_insert_u32">sms_insert_u32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_itr_f">sms_itr_f</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sms_clear">sms_clear</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_delete_d">sms_delete_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_free">sms_free</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_it_d">sms_it_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_itr_i">sms_itr_i</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sms_count_d">sms_count_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_delete_f">sms_delete_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_grow">sms_grow</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_it_f">sms_it_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_itr_i32">sms_itr_i32</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sms_count_f">sms_count_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_delete_i">sms_delete_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_insert_d">sms_insert_d</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_it_i">sms_it_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_itr_s">sms_itr_s</a>&nbsp;</th></tr><tr><th align="left">&nbsp;<a href="#sms_count_i">sms_count_i</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_delete_i32">sms_delete_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_insert_f">sms_insert_f</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_it_i32">sms_it_i32</a>&nbsp;</th><th align="left">&nbsp;<a href="#sms_itr_u32">sms_itr_u32</a>&nbsp;</th></tr></table><br><br><i>srt_set *</i><b><a name="sms_alloc">sms_alloc</a></b>(<i>enum eSMS_Type t</i>, <i>size_t initial_num_elems_reserve</i>)<br><br><ul><li>Allocate set (heap)</li><li><b>enum eSMS_Type t</b>: set type</li><li><b>size_t initial_num_elems_reserve</b>:  initial reserve</li><li><b>Return</b> (<i>srt_set *</i>): set</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_set *</i><b><a name="sms_alloca">sms_alloca</a></b>(<i>enum eSMS_Type t</i>, <i>size_t n</i>)<br><br><ul><li>Allocate set (stack)</li><li><b>enum eSMS_Type t</b>: set type</li><li><b>size_t n</b>:  initial reserve</li><li><b>Return</b> (<i>srt_set *</i>): set</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_capacity">sms_capacity</a></b>(<i>const srt_set *s</i>)<br><br><ul><li>Allocated space</li><li><b>const srt_set *s</b>: set</li><li><b>Return</b> (<i>size_t</i>): current allocated space (vector elements)</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_capacity_left">sms_capacity_left</a></b>(<i>const srt_set *s</i>)<br><br><ul><li>Preallocated space left</li><li><b>const srt_set *s</b>: set</li><li><b>Return</b> (<i>size_t</i>): allocated space left</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sms_clear">sms_clear</a></b>(<i>srt_set *s</i>)<br><br><ul><li>Reset/clean set (keeping set type)</li><li><b>srt_set *s</b>: set</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple sets, O(n) for sets having nodes with strings</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_count_d">sms_count_d</a></b>(<i>const srt_set *s</i>, <i>double k</i>)<br><br><ul><li>Set element count/check (SMS_D)</li><li><b>const srt_set *s</b>: set</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the set</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_count_f">sms_count_f</a></b>(<i>const srt_set *s</i>, <i>float k</i>)<br><br><ul><li>Set element count/check (SMS_F)</li><li><b>const srt_set *s</b>: set</li><li><b>float k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the set</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_count_i">sms_count_i</a></b>(<i>const srt_set *s</i>, <i>int64_t k</i>)<br><br><ul><li>Set element count/check (SMS_I)</li><li><b>const srt_set *s</b>: set</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the set</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_count_i32">sms_count_i32</a></b>(<i>const srt_set *s</i>, <i>int32_t k</i>)<br><br><ul><li>Set element count/check (SMS_I32)</li><li><b>const srt_set *s</b>: set</li><li><b>int32_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the set</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_count_s">sms_count_s</a></b>(<i>const srt_set *s</i>, <i>const srt_string *k</i>)<br><br><ul><li>Set element count/check (SMS_S)</li><li><b>const srt_set *s</b>: set</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the set</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_count_u32">sms_count_u32</a></b>(<i>const srt_set *s</i>, <i>uint32_t k</i>)<br><br><ul><li>Set element count/check (SMS_U32)</li><li><b>const srt_set *s</b>: set</li><li><b>uint32_t k</b>:  key</li><li><b>Return</b> (<i>size_t</i>): S_TRUE: element found; S_FALSE: not in the set</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_set *</i><b><a name="sms_cpy">sms_cpy</a></b>(<i>srt_set **s</i>, <i>const srt_set *src</i>)<br><br><ul><li>Overwrite set with a set copy</li><li><b>srt_set **s</b>: output set</li><li><b>const srt_set *src</b>:  input set</li><li><b>Return</b> (<i>srt_set *</i>): output set reference (optional usage)</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_delete_d">sms_delete_d</a></b>(<i>srt_set *s</i>, <i>double k</i>)<br><br><ul><li>Delete element (SMS_D)</li><li><b>srt_set *s</b>: set</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_delete_f">sms_delete_f</a></b>(<i>srt_set *s</i>, <i>float k</i>)<br><br><ul><li>Delete element (SMS_F)</li><li><b>srt_set *s</b>: set</li><li><b>float k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_delete_i">sms_delete_i</a></b>(<i>srt_set *s</i>, <i>int64_t k</i>)<br><br><ul><li>Delete element (SMS_I)</li><li><b>srt_set *s</b>: set</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_delete_i32">sms_delete_i32</a></b>(<i>srt_set *s</i>, <i>int32_t k</i>)<br><br><ul><li>Delete element (SMS_I32)</li><li><b>srt_set *s</b>: set</li><li><b>int32_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_delete_s">sms_delete_s</a></b>(<i>srt_set *s</i>, <i>const srt_string *k</i>)<br><br><ul><li>Delete element (SMS_S)</li><li><b>srt_set *s</b>: set</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_delete_u32">sms_delete_u32</a></b>(<i>srt_set *s</i>, <i>uint32_t k</i>)<br><br><ul><li>Delete element (SMS_U32)</li><li><b>srt_set *s</b>: set</li><li><b>uint32_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: found and deleted; S_FALSE: not found</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_set *</i><b><a name="sms_dup">sms_dup</a></b>(<i>const srt_set *src</i>)<br><br><ul><li>Duplicate set</li><li><b>const srt_set *src</b>: input set</li><li><b>Return</b> (<i>srt_set *</i>): output set</li><li><b>Time complexity:</b> O(n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_empty">sms_empty</a></b>(<i>const srt_set *s</i>)<br><br><ul><li>Tells if a set is empty (zero elements)</li><li><b>const srt_set *s</b>: set</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: empty vector; S_FALSE: not empty</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>void </i><b><a name="sms_free">sms_free</a></b>(<i>srt_map **s</i>, <i>...</i>)<br><br><ul><li>Free one or more sets (heap)</li><li><b>srt_map **s</b>: set</li><li><b>...</b>:  more sets (optional)</li><li><b>Return</b> (<i>void</i>): -</li><li><b>Time complexity:</b> O(1) for simple sets, O(n) for string sets</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_grow">sms_grow</a></b>(<i>srt_set **s</i>, <i>size_t extra_elems</i>)<br><br><ul><li>Ensure space for extra elements</li><li><b>srt_set **s</b>: set</li><li><b>size_t extra_elems</b>: number of extra elements</li><li><b>Return</b> (<i>size_t</i>): extra size allocated</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_insert_d">sms_insert_d</a></b>(<i>srt_set **s</i>, <i>double k</i>)<br><br><ul><li>Insert element (SMS_D)</li><li><b>srt_set **s</b>: set</li><li><b>double k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_insert_f">sms_insert_f</a></b>(<i>srt_set **s</i>, <i>float k</i>)<br><br><ul><li>Insert element (SMS_F)</li><li><b>srt_set **s</b>: set</li><li><b>float k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_insert_i">sms_insert_i</a></b>(<i>srt_set **s</i>, <i>int64_t k</i>)<br><br><ul><li>Insert element (SMS_I)</li><li><b>srt_set **s</b>: set</li><li><b>int64_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_insert_i32">sms_insert_i32</a></b>(<i>srt_set **s</i>, <i>int32_t k</i>)<br><br><ul><li>Insert element (SMS_I32)</li><li><b>srt_set **s</b>: set</li><li><b>int32_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_insert_s">sms_insert_s</a></b>(<i>srt_set **s</i>, <i>const srt_string *k</i>)<br><br><ul><li>Insert element (SMS_S)</li><li><b>srt_set **s</b>: set</li><li><b>const srt_string *k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_bool </i><b><a name="sms_insert_u32">sms_insert_u32</a></b>(<i>srt_set **s</i>, <i>uint32_t k</i>)<br><br><ul><li>Insert element (SMS_U32)</li><li><b>srt_set **s</b>: set</li><li><b>uint32_t k</b>:  key</li><li><b>Return</b> (<i>srt_bool</i>): S_TRUE: OK, S_FALSE: insertion error</li><li><b>Time complexity:</b> O(log n)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>double </i><b><a name="sms_it_d">sms_it_d</a></b>(<i>const srt_set *s</i>, <i>srt_tndx i</i>)<br><br><ul><li>Enumerate elements (SMS_D)</li><li><b>const srt_set *s</b>: set</li><li><b>srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>double</i>): double</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>float </i><b><a name="sms_it_f">sms_it_f</a></b>(<i>const srt_set *s</i>, <i>srt_tndx i</i>)<br><br><ul><li>Enumerate elements (SMS_F)</li><li><b>const srt_set *s</b>: set</li><li><b>srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>float</i>): float</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="sms_it_i">sms_it_i</a></b>(<i>const srt_set *s</i>, <i>srt_tndx i</i>)<br><br><ul><li>Enumerate elements (SMS_I)</li><li><b>const srt_set *s</b>: set</li><li><b>srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int32_t</i>): int64_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="sms_it_i32">sms_it_i32</a></b>(<i>const srt_set *s</i>, <i>srt_tndx i</i>)<br><br><ul><li>Enumerate elements (SMS_I32)</li><li><b>const srt_set *s</b>: set</li><li><b>srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int32_t</i>): int32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>int32_t </i><b><a name="sms_it_s">sms_it_s</a></b>(<i>const srt_set *s</i>, <i>srt_tndx i</i>)<br><br><ul><li>Enumerate elements (SMS_S)</li><li><b>const srt_set *s</b>: set</li><li><b>srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>int32_t</i>): string</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>uint32_t </i><b><a name="sms_it_u32">sms_it_u32</a></b>(<i>const srt_set *s</i>, <i>srt_tndx i</i>)<br><br><ul><li>Enumerate elements (SMS_U32)</li><li><b>const srt_set *s</b>: set</li><li><b>srt_tndx i</b>:  element, 0 to n - 1</li><li><b>Return</b> (<i>uint32_t</i>): uint32_t</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_itr_d">sms_itr_d</a></b>(<i>const srt_set *s</i>, <i>double key_min</i>, <i>double key_max</i>, <i>srt_set_it_d f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate elements in a given key range (SMS_D)</li><li><b>const srt_set *s</b>: set</li><li><b>double key_min</b>:  key lower bound</li><li><b>double key_max</b>:  key upper bound</li><li><b>srt_set_it_d f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_itr_f">sms_itr_f</a></b>(<i>const srt_set *s</i>, <i>float key_min</i>, <i>float key_max</i>, <i>srt_set_it_f f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate elements in a given key range (SMS_F)</li><li><b>const srt_set *s</b>: set</li><li><b>float key_min</b>:  key lower bound</li><li><b>float key_max</b>:  key upper bound</li><li><b>srt_set_it_f f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_itr_i">sms_itr_i</a></b>(<i>const srt_set *s</i>, <i>int64_t key_min</i>, <i>int64_t key_max</i>, <i>srt_set_it_i f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate elements in a given key range (SMS_I)</li><li><b>const srt_set *s</b>: set</li><li><b>int64_t key_min</b>:  key lower bound</li><li><b>int64_t key_max</b>:  key upper bound</li><li><b>srt_set_it_i f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_itr_i32">sms_itr_i32</a></b>(<i>const srt_set *s</i>, <i>int32_t key_min</i>, <i>int32_t key_max</i>, <i>srt_set_it_i32 f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate elements in a given key range (SMS_I32)</li><li><b>const srt_set *s</b>: set</li><li><b>int32_t key_min</b>:  key lower bound</li><li><b>int32_t key_max</b>:  key upper bound</li><li><b>srt_set_it_i32 f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_itr_s">sms_itr_s</a></b>(<i>const srt_set *s</i>, <i>const srt_string *key_min</i>, <i>const srt_string *key_max</i>, <i>srt_set_it_s f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate elements in a given key range (SMS_S)</li><li><b>const srt_set *s</b>: set</li><li><b>const srt_string *key_min</b>:  key lower bound</li><li><b>const srt_string *key_max</b>:  key upper bound</li><li><b>srt_set_it_s f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_itr_u32">sms_itr_u32</a></b>(<i>const srt_set *s</i>, <i>uint32_t key_min</i>, <i>uint32_t key_max</i>, <i>srt_set_it_u32 f</i>, <i>void *context</i>)<br><br><ul><li>Enumerate elements in a given key range (SMS_U32)</li><li><b>const srt_set *s</b>: set</li><li><b>uint32_t key_min</b>:  key lower bound</li><li><b>uint32_t key_max</b>:  key upper bound</li><li><b>srt_set_it_u32 f</b>:  callback function</li><li><b>void *context</b>:  callback function context</li><li><b>Return</b> (<i>size_t</i>): Elements processed</li><li><b>Time complexity:</b> O(log n) + O(log m)</li><li><b>Space complexity:</b> additional 2 * O(log n) space required, allocated on the stack, i.e. fast</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_reserve">sms_reserve</a></b>(<i>srt_set **s</i>, <i>size_t max_elems</i>)<br><br><ul><li>Ensure space for elements</li><li><b>srt_set **s</b>: set</li><li><b>size_t max_elems</b>: absolute element reserve</li><li><b>Return</b> (<i>size_t</i>): reserved elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>srt_set *</i><b><a name="sms_shrink">sms_shrink</a></b>(<i>srt_set **s</i>)<br><br><ul><li>Make the set use the minimum possible memory</li><li><b>srt_set **s</b>: set</li><li><b>Return</b> (<i>srt_set *</i>): set reference (optional usage)</li><li><b>Time complexity:</b> O(1) for allocators using memory reset</li><li><b>Space complexity:</b> O(n) for naive allocators</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
<i>size_t </i><b><a name="sms_size">sms_size</a></b>(<i>const srt_set *s</i>)<br><br><ul><li>Get set size</li><li><b>const srt_set *s</b>: set</li><li><b>Return</b> (<i>size_t</i>): Set number of elements</li><li><b>Time complexity:</b> O(1)</li><li><b>Space complexity:</b> no extra space</li><li><b>Coverage:</b> [1/2] test covered (test + Valgrind)</li><li><b>Quality:</b> [2/4] reviewed, clean (-Wall, style, speed)</li></ul><br><br>
</body></html>

